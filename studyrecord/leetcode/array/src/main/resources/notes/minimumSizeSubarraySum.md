# 长度最小的子数组

给定一个含有 n 个正整数的数组和一个正整数 target。找出该数组中满足其和 >= target 
的长度最小的**连续**子数组 [nums[l], nums[l+1], ..., nums[r-l], nums[r]]，并返回其长度，
如果不存在符合条件的子数组， 返回 0。

## 暴力解法

双层 for 循环暴力求解，在数组中从开始不断地开始寻找最小的子串；

1. 第一层 for 循环，每次初始化最小求和 sum 值；因为每次都是重新计算；
2. 第二层 for 循环，计算数组中元素相加之和大于 target 的元素，并计算下标间隔长度 subLength，
并比较上一次的长度，取最小值作为结果 result；
3. resul 结果是否重新被赋值，有则返回 0；否则返回 result值；


