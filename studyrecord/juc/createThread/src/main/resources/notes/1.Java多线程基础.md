# Java å¤šçº¿ç¨‹
åœ¨çº¿ç¨‹è¿™ä¸ªæ¦‚å¿µæå‡ºä¹‹å‰ï¼Œåœ¨æ“ä½œç³»ç»Ÿä¸­åªæœ‰è¿›ç¨‹çš„æ¦‚å¿µã€‚è¿›ç¨‹æ˜¯æ“ä½œç³»ç»Ÿç»“æ„çš„åŸºç¡€ï¼›æ˜¯ä¸€æ¬¡ç¨‹åºçš„æ‰§è¡Œã€‚æ˜¯ç³»ç»Ÿè¿›è¡Œèµ„æºåˆ†é…å’Œ
è°ƒåº¦çš„ä¸€ä¸ªç‹¬ç«‹å•ä½ã€‚

ç¨‹åºæ˜¯æŒ‡åºåˆ—æŒ‡ä»¤ï¼Œè¿™äº›æŒ‡ä»¤å¯ä»¥è®© CPU æŒ‰ç…§äººç±»æŒ‡ä»¤å®Œæˆç›¸åº”çš„ä»»åŠ¡ã€‚åœ¨æ“ä½œç³»ç»Ÿä¸­å¯åŠ¨ä¸€ä¸ª JVM è™šæ‹Ÿæœºå°±ç›¸å½“äºåˆ›å»ºäº†ä¸€ä¸ªè¿›ç¨‹ã€‚

é‚£ä»€ä¹ˆæ˜¯çº¿ç¨‹å‘¢ï¼Ÿçº¿ç¨‹æ˜¯è¿›ç¨‹ä¸­ç‹¬ç«‹è¿è¡Œçš„å­ä»»åŠ¡ï¼Œå¯ä»¥å…±äº«è¿›ç¨‹ä¸­ç›¸åŒçš„å†…å­˜æˆ–æ–‡ä»¶èµ„æºã€‚

# Java çº¿ç¨‹çš„ä½¿ç”¨

## ç»§æ‰¿ Thread ç±»

Java JDK ä¸­åŒ…å«äº†å¯¹å¤šçº¿ç¨‹æŠ€æœ¯çš„æ”¯æŒã€‚å®ç°å¤šçº¿ç¨‹ç¼–ç¨‹ä¸»è¦æœ‰ä¸¤ç§æ–¹å¼ï¼š

1. ç»§æ‰¿ Thread ç±»ï¼›

2. å®ç° Runnable æ¥å£

### ç»§æ‰¿ Thread ç±»

```java
public class CreateThreadByExtendsThread extends Thread{
    @Override
    public void run() {
        super.run();
        System.out.println("Create Thread by Extends Thread Begin to Run!");
    }
}
```


```java
public class ThreadTest {
    public static void main(String[] args) {
        CreateThreadByExtendsThread t = new CreateThreadByExtendsThread();
        t.setName("CreateThreadByExtendsThread"); // æŒ‡å®šçº¿ç¨‹æ‰§è¡Œåç§°
        t.start();  // è€—æ—¶è¾ƒé•¿
        System.out.println("å½“å‰çº¿ç¨‹" + Thread.currentThread().getName() + "æ‰§è¡Œç»“æŸ\n" + "å½“å‰çº¿ç¨‹" + t.getName() + "æ‰§è¡Œç»“æŸ"); //ä¸»çº¿ç¨‹è€—æ—¶è¾ƒçŸ­
    }
}
```

å¤šæ¬¡æ‰§è¡Œçš„ç»“æœï¼Œä»”ç»†è§‚å¯Ÿå°±ä¼šå‘ç°ï¼Œè¾“å‡ºç»“æœå¹¶ä¸æ˜¯éšç€è°ƒç”¨é¡ºåºè€Œè¾“å‡ºçš„ã€‚è€Œç¨‹åºä¸­æ‰§è¡Œ startæ–¹æ³•æ¯”è¾ƒè€—æ—¶æ˜¯å› ä¸ºè¯¥æ–¹æ³•æ‰§è¡Œäº†å¤šä¸ªæ­¥éª¤ã€‚æ­¥éª¤å¦‚ä¸‹ï¼š

1. é€šè¿‡ JVM å‘Šè¯‰æ“ä½œç³»ç»Ÿåˆ›å»º Threadï¼›

2. é€šè¿‡æ“ä½œç³»ç»Ÿå¼€è¾Ÿå†…å­˜å¹¶ä½¿ç”¨æ“ä½œç³»ç»Ÿ SDK ä¸­çš„ createThread() å‡½æ•°åˆ›å»º Thread çº¿ç¨‹å¯¹è±¡ï¼›

3. æ“ä½œç³»ç»Ÿå¯¹ Thread å¯¹è±¡è¿›è¡Œè°ƒåº¦ï¼Œä»¥ç¡®å®šæ‰§è¡Œæ—¶æœºï¼›

4. Thread åœ¨æ“ä½œç³»ç»Ÿä¸­è¢«æ‰§è¡ŒæˆåŠŸ

ä»¥ä¸Š4ä¸ªæ­¥éª¤æ‰§è¡Œå®Œæˆæ¶ˆè€—çš„æ—¶é—´ä¸€å®šå¤§äº main æ–¹æ³•ä¸­çš„è¾“å‡ºæ—¶é—´ã€‚è€Œä¸” main æ–¹æ³•æ‰§è¡Œ start() æ–¹æ³•æ—¶ä¸éœ€è¦ç­‰4ä¸ªæ­¥éª¤éƒ½æ‰§è¡Œå®Œæ¯•ï¼Œè€Œæ˜¯ç»§ç»­æ‰§è¡Œ start()
æ–¹æ³•åé¢çš„ä»£ç ï¼Œå¦‚æœåœ¨ä¸»çº¿ç¨‹ä¸­ç›´æ¥è°ƒç”¨ run æ–¹æ³•ï¼Œè¾“å‡ºé¡ºåºå°±æ˜¯æŒ‰ç…§ä»£ç é¡ºåºè¾“å‡ºï¼Œæ­¤æ—¶çš„ run æ–¹æ³•æ˜¯ç”±ä¸»çº¿ç¨‹è°ƒç”¨çš„ï¼Œæ‰€ä»¥æ‰ä¼šæŒ‰ç…§ä»£ç é¡ºåºæ‰§è¡Œã€‚

å¤šçº¿ç¨‹éšæœºè¾“å‡ºçš„åŸå› æ˜¯ CPU å°†æ—¶é—´ç‰‡åˆ†ç»™ä¸åŒçš„çº¿ç¨‹ï¼Œçº¿ç¨‹è·å¾—æ—¶é—´ç‰‡åå°±å¼€å§‹æ‰§è¡Œä»»åŠ¡ï¼Œçº¿ç¨‹è·å¾—æ—¶é—´ç‰‡æ˜¯éšæœºçš„ï¼Œæ‰§è¡Œè¾“å‡ºçš„é¡ºåºè‡ªç„¶ä¹Ÿæ˜¯ä¹±åºçš„ã€‚

## å®ç° Runnable æ¥å£

å¦‚æœæƒ³åˆ›å»ºçš„çº¿ç¨‹ç±»å·²ç»æœ‰äº†ä¸€ä¸ªçˆ¶ç±»äº†ï¼Œé‚£ä¹ˆå°±ä¸èƒ½å†ç»§æ‰¿ Thread ç±»ï¼Œæ­¤æ—¶å°±éœ€è¦å®ç° Runnable æ¥å£æ¥è§£å†³è¿™æ ·çš„é—®é¢˜ã€‚

```java
public class CreateThreadByRunnable implements Runnable{

    @Override
    public void run() {
        System.out.println("Create Thread by implements Runnable Begin to Run!");
    }
}
```

```
public class ThreadTest {
    public static void main(String[] args) {
        CreateThreadByRunnable runnable = new CreateThreadByRunnable();
        Thread t2 = new Thread(runnable);
        t2.setName("CreateThreadByRunnable");
        t2.start();  // è€—æ—¶è¾ƒé•¿
        System.out.println("å½“å‰çº¿ç¨‹" + Thread.currentThread().getName() + "æ‰§è¡Œç»“æŸ\n" + "å½“å‰çº¿ç¨‹" + t2.getName() + "æ‰§è¡Œç»“æŸ"); //ä¸»çº¿ç¨‹è€—æ—¶è¾ƒçŸ­
    }
}
```

### ä½¿ç”¨ Runnable æ¥å£å®ç°å¤šçº¿ç¨‹çš„ä¼˜ç‚¹

ä½¿ç”¨ç»§æ‰¿ Thread ç±»çš„æ–¹å¼å®ç°å¤šçº¿ç¨‹åœ¨ç¨‹åºè®¾è®¡ä¸Šæ˜¯æœ‰å±€é™æ€§çš„ï¼Œè¿™æ˜¯ç”± Java æœ¬èº«ä¸æ”¯æŒå¤šç»§æ‰¿å¯¼è‡´çš„ã€‚ä¸ºäº†è§£å†³è¿™æ ·çš„å±€é™æ€§ï¼Œå› æ­¤é‡‡ç”¨å®ç° Runnable
æ¥å£æ¥å®ç°å¤šçº¿ç¨‹çš„å¼€å‘

åœ¨ Thread.java ç±»ä¸­ä¹Ÿå®ç°äº† Runnable æ¥å£ã€‚

```java
public
class Thread implements Runnable {
    /* Make sure registerNatives is the first thing <clinit> does. */
    private static native void registerNatives();

    static {
        registerNatives();
    }
    //...çœç•¥
}
```

æµ‹è¯•ä»£ç å¦‚ä¸‹ï¼š

```
public class ThreadTest {
    public static void main(String[] args) {
        CreateThreadByExtendsThread t = new CreateThreadByExtendsThread();
        t.setName("CreateThreadByExtendsThread"); // æŒ‡å®šçº¿ç¨‹æ‰§è¡Œåç§°
        t.start();  // è€—æ—¶è¾ƒé•¿
        System.out.println("å½“å‰çº¿ç¨‹" + Thread.currentThread().getName() + "æ‰§è¡Œç»“æŸ\n" + "å½“å‰çº¿ç¨‹" + t.getName() + "æ‰§è¡Œç»“æŸ"); //ä¸»çº¿ç¨‹è€—æ—¶è¾ƒçŸ­
        
        // CreateThreadByExtendsThread æ˜¯ Thread å­ç±»ï¼Œ
        // Thread æ˜¯ Runnable å­ç±»ï¼Œæ‰€ä»¥ CreateThreadByExtendsThread ç›¸å½“äº Thread çš„å®ç°ç±»
        // æ‰€ä»¥æ„é€ å‡½æ•°å¯ä»¥ä¼ å…¥ä¸€ä¸ª Thread ç±»ï¼Œè¿™æ ·å®Œå…¨å¯ä»¥å°† Thread ç±»å¯¹è±¡ä¸­çš„ run æ–¹æ³•äº¤ç”±å…¶ä»–çº¿ç¨‹è°ƒç”¨
        
        Thread t3 = new Thread(t);
        t3.setName("æµ‹è¯•Threadå¯ä»¥ä¼ å…¥Runnableæ¥å£");
        t3.start();
    }
}
```

# å®ç° Runnable æ¥å£ä¸ç»§æ‰¿ Thread ç±»çš„å†…éƒ¨æµç¨‹

## Threadæ‰§è¡Œæµç¨‹ï¼š

![Threadæ‰§è¡Œæµç¨‹](../å›¾ç‰‡/1.extendsThreadExecuteProccess.png)

åˆ›å»ºçº¿ç¨‹çš„æ—¶å€™å¯ä»¥ä¸ºçº¿ç¨‹æŒ‡å®šåå­—ï¼Œå¦‚æœæ²¡æœ‰æŒ‡å®šï¼Œçº¿ç¨‹åœ¨åˆ›å»ºçš„æ—¶å€™ä¼šè‡ªåŠ¨ä¸ºå®ƒç”Ÿæˆåå­—ã€‚è¿™ä¸ªæ“ä½œåœ¨ Thread çš„æ— å‚æ„é€ ä¸­ã€‚åœ¨æ— å‚æ„é€ å‡½æ•°ä¸­åˆ›å»º
è¿˜è°ƒç”¨äº† init æ–¹æ³•ï¼Œå®Œæˆå¯¹çº¿ç¨‹å±æ€§çš„åˆå§‹åŒ–ã€‚æºç å¦‚ä¸‹ï¼š

```
/**
 * Allocates a new {@code Thread} object. This constructor has the same
 * effect as {@linkplain #Thread(ThreadGroup,Runnable,String) Thread}
 * {@code (null, null, gname)}, where {@code gname} is a newly generated
 * name. Automatically generated names are of the form
 * {@code "Thread-"+}<i>n</i>, where <i>n</i> is an integer.
 */
public Thread() {
    init(null, null, "Thread-" + nextThreadNum(), 0);
}
```

### Thread å±æ€§

init æ–¹æ³•å®Œæˆå¯¹çº¿ç¨‹å±æ€§çš„åˆå§‹åŒ–ï¼Œäº†è§£ä¸€ä¸‹ Thread ç±»åŒ…å«äº†å“ªäº›å±æ€§ï¼š

```
private volatile String name; // çº¿ç¨‹åç§°
private int            priority; // çº¿ç¨‹ä¼˜å…ˆçº§ (ToDo : æœ‰å¤šå°‘çº§)
private boolean     single_step; // çº¿ç¨‹æ˜¯å¦å•æ­¥æ‰§è¡Œ é»˜è®¤ false
private boolean     daemon = false; // çº¿ç¨‹æ˜¯å¦ä¸ºå®ˆæŠ¤çº¿ç¨‹(ToDo: ä»€ä¹ˆæ˜¯å®ˆæŠ¤çº¿ç¨‹)
private boolean     stillborn = false; // è™šæ‹ŸæœºçŠ¶æ€ (ToDo 2: æœ‰å“ªäº›ï¼Œæœ‰ä»€ä¹ˆä½œç”¨)

private Runnable target; // æœ€ç»ˆçº¿ç¨‹çš„é€»è¾‘æ‰§è¡Œæ˜¯é€šè¿‡ target è°ƒç”¨æ‰§è¡Œ
private ThreadGroup group; // çº¿ç¨‹ç»„(ToDo: çº¿ç¨‹ç»„çš„ä½œç”¨)
private ClassLoader contextClassLoader; // æ­¤çº¿ç¨‹çš„ ClassLoader(ç±»åŠ è½½å™¨)

private AccessControlContext inheritedAccessControlContext; // å½“å‰çº¿ç¨‹ç»§æ‰¿çš„æƒé™ï¼šæ§åˆ¶ä¸Šä¸‹æ–‡ã€ä»¥åŠå®‰å…¨æœºåˆ¶ç›¸å…³(æœªæ¥å¯èƒ½è¢«åºŸå¼ƒ)
private static int threadInitNumber; // è‡ªåŠ¨ç¼–å·åŒ¿åçº¿ç¨‹ å³æ²¡æœ‰ä¸»åŠ¨å‘½åçš„çº¿ç¨‹
ThreadLocal.ThreadLocalMap threadLocals = null;; // æ­¤çº¿ç¨‹çš„æœ¬åœ°å˜é‡å€¼.æ­¤mapç”±ThreadLocalç±»è¿›è¡Œç»´æŠ¤,å› ä¸ºè¿™ä¸ªç±»åœ¨ThreadLocalä¸­æ˜¯åŒ…çº§ç§æœ‰çš„, ThreadLocalMap æ˜¯ä¸€ä¸ªç”¨äºç»´æŠ¤çº¿ç¨‹æœ¬åœ°å˜é‡çš„ hashMao
ThreadLocal.ThreadLocalMap inheritableThreadLocals = null; // æ­¤çº¿ç¨‹ç»§æ‰¿æ‹¥æœ‰çš„æœ¬åœ°å˜é‡å€¼ï¼Œå³ A çº¿ç¨‹ç»§æ‰¿ Bçº¿ç¨‹ç§°ï¼Œ é‚£ä¹ˆ B çº¿ç¨‹ä¸­ threadLocals ç»´æŠ¤çš„å˜é‡åœ¨å­˜æ”¾åˆ°è¿™ inheritableThreadLocals ä¸­


private long stackSize;  //æ­¤çº¿ç¨‹è¯·æ±‚çš„å †æ ˆå¤§å°ï¼Œå¦‚æœåˆ›å»ºè€…æœªæŒ‡å®šå †æ ˆå¤§å°ï¼Œåˆ™ä¸º 0ã€‚æœ€ç»ˆç”±è™šæ‹ŸæŒ‡å®š(äººä¸ºæŒ‡å®šä¼šä¸ä¼šç”Ÿæ•ˆ)ï¼›ä¸€äº›è™šæ‹Ÿæœºä¼šå¿½ç•¥å®ƒã€‚
private long nativeParkEventPointer; //åœ¨æœ¬æœºçº¿ç¨‹ç»ˆæ­¢åæŒç»­å­˜åœ¨çš„ JVM ç§æœ‰çŠ¶æ€ (ToDo: ä¸çŸ¥é“æœ‰ä»€ä¹ˆä½œç”¨)
private long tid; çº¿ç¨‹ ID
private static long threadSeqNumber; // ç”¨äºç”Ÿæˆçº¿ç¨‹ ID
private volatile int threadStatus = 0; // (ToDo: çº¿ç¨‹æœ‰å“ªäº›çŠ¶æ€ 0: è¡¨ç¤ºæœªå¯åŠ¨)
volatile Object parkBlocker; // æä¾›ç»™å½“å‰è°ƒç”¨ java.util.concurrent.locks.LockSupport.park çš„å‚æ•°ã€‚ç”±ï¼ˆç§æœ‰ï¼‰java.util.concurrent.locks.LockSupport.setBlocker è®¾ç½®ä½¿ç”¨ï¼Œ ç”±java.util.concurrent.locks.LockSupport.getBlocker è®¿é—®
private volatile Interruptible blocker; // å½“å‰çº¿ç¨‹åœ¨å¯ä¸­æ–­çš„ I/O æ“ä½œä¸­å¤„äºé˜»å¡çŠ¶æ€æ—¶ï¼Œåœ¨è®¾ç½®äº†å¯¹è±¡çš„ interrupt çŠ¶æ€åï¼Œå¿…é¡»è°ƒç”¨è¿™ä¸ªå¯¹è±¡çš„ interrupt æ–¹æ³•(ToDo: åé¢äº†è§£ä¸€ä¸‹)
public final static int MIN_PRIORITY = 1; // çº¿ç¨‹å…·å¤‡çš„æœ€ä½ä¼˜å…ˆçº§
public final static int NORM_PRIORITY = 5; // åˆ†é…ç»™çº¿ç¨‹é»˜è®¤çš„ä¼˜å…ˆçº§ï¼Œè¿™é‡Œçš„ä¼˜å…ˆçº§æ˜¯ä¸€ä¸ªå¤©èŠ±æ¿ï¼Œè€Œä¸æ˜¯ä¸€ä¸ªè®°å½•å°º
public final static int MAX_PRIORITY = 10; // çº¿ç¨‹æ‹¥æœ‰çš„æœ€å¤§ä¼˜å…ˆçº§ 10 
```

Thread çš„æ‰€æœ‰å±æ€§ä½œç”¨å’Œä½¿ç”¨åœºæ™¯ï¼Œä»¥åŠå˜é‡å‰é¢çš„ä¿®é¥°ç¬¦äº†è§£ä¸‹ã€‚åé¢å†æ·±å…¥ç ”ç©¶å§ã€‚ğŸ˜†

### init åˆå§‹åŒ–

```
public Thread() {
    init(null, null, "Thread-" + nextThreadNum(), 0);
}
```

nextThreadNum() å‡½æ•°æºç : ç”Ÿæˆå½“å‰çº¿ç¨‹ ID
```
private static synchronized int nextThreadNum() {
    return threadInitNumber++;
}
```
åœ¨ init æ–¹æ³•è°ƒç”¨äº† é‡è½½å®ç°çš„ initæ–¹æ³•ï¼Œæºç å¦‚ä¸‹ï¼š
```text
/**
 * Initializes a Thread with the current AccessControlContext.
 * @see #init(ThreadGroup,Runnable,String,long,AccessControlContext,boolean)
 */
private void init(ThreadGroup g, Runnable target, String name,
                  long stackSize) {
    init(g, target, name, stackSize, null, true);
}
```

#### çº¿ç¨‹åˆå§‹åŒ–æ ¸å¿ƒ

```
/**
 * Initializes a Thread.
 *
 * @param g the Thread group
 * @param target the object whose run() method gets called
 * @param name the name of the new Thread
 * @param stackSize the desired stack size for the new thread, or
 *        zero to indicate that this parameter is to be ignored.
 * @param acc the AccessControlContext to inherit, or
 *            AccessController.getContext() if null
 * @param inheritThreadLocals if {@code true}, inherit initial values for
 *            inheritable thread-locals from the constructing thread
 */
private void init(ThreadGroup g, Runnable target, String name,
                  long stackSize, AccessControlContext acc,
                  boolean inheritThreadLocals) {
    // å¯ä»¥çœ‹åˆ°å¦‚æœçº¿ç¨‹åç§° nullï¼Œ ä¼šç›´æ¥æŠ›å‡ºå¼‚å¸¸
    if (name == null) {
        throw new NullPointerException("name cannot be null");
    }
    // çº¿ç¨‹åç§°èµ‹å€¼
    this.name = name;
    // currentThread() è·å–å½“å‰çº¿ç¨‹æ­£åœ¨è¢«é‚£ä¸ªçº¿ç¨‹è°ƒç”¨
    Thread parent = currentThread();
    // è·å–ç³»ç»Ÿå®‰å…¨ç®¡ç†ï¼Œæ²¡æœ‰è¿”å› null ä½œç”¨ï¼šé˜²æ­¢å¯åŠ¨Java ç¨‹åºä¸­ï¼Œæœ‰æ¶æ„ä»£ç (åˆ é™¤ç³»ç»Ÿæ–‡ä»¶ã€é‡å¯ç³»ç»Ÿ)ï¼Œè¿™ä¸ªæ—¶å€™å°±éœ€è¦å¯åŠ¨ Java å®‰å…¨
    // ç®¡ç†å™¨ï¼Œ æ€ä¹ˆä½¿ç”¨å¯ä»¥çœ‹ä¸‹è¿™ä¸ªï¼š https://cloud.tencent.com/developer/article/1793295
    SecurityManager security = System.getSecurityManager();
    // å¦‚æœçº¿ç¨‹ç»„æ²¡æœ‰æ˜¾ç¤ºä¼ å…¥ ä¸º null
    if (g == null) {
        /* Determine if it's an applet or not */

        /* If there is a security manager, ask the security manager
           what to do. */
        // å¦‚æœå¼€å¯äº†å®‰å…¨ç®¡ç†å™¨ï¼Œåˆ™å½“å‰çº¿ç¨‹ç»„ g = å®‰å…¨ç®¡ç†å™¨çš„çº¿ç¨‹ç»„
        if (security != null) {
            g = security.getThreadGroup();
        }

        /* If the security doesn't have a strong opinion of the matter
           use the parent thread group. */
        // å¦‚æœæ²¡æœ‰å¼€å¯å®‰å…¨ç®¡å™¨ï¼Œåˆ™è·å–è°ƒç”¨å½“å‰çº¿ç¨‹çš„çº¿ç¨‹ç»„
        if (g == null) {
            g = parent.getThreadGroup();
        }
    }

    /* checkAccess regardless of whether or not threadgroup is
       explicitly passed in. */
    // ç¡®å®šå½“å‰çº¿ç¨‹æ˜¯å¦æœ‰æƒé™ä¿®æ”¹çº¿ç¨‹ç»„
    g.checkAccess();

    /*
     * Do we have the required permissions?
     */
     // æ˜¯å¦å¼€å¯äº†å®‰å…¨ç®¡ç†å™¨
    if (security != null) {
        if (isCCLOverridden(getClass())) {
            security.checkPermission(SUBCLASS_IMPLEMENTATION_PERMISSION);
        }
    }

    // å¢åŠ æœªå¯åŠ¨çº¿ç¨‹çš„è®¡æ•°
    g.addUnstarted();
    // çº¿ç¨‹ç»„çš„èµ‹å€¼
    this.group = g;
    // å®ˆæŠ¤è¿›ç¨‹æ ‡ç¤ºèµ‹å€¼é»˜è®¤false
    this.daemon = parent.isDaemon();
    // çº¿ç¨‹ä¼˜å…ˆçº§
    this.priority = parent.getPriority();
    if (security == null || isCCLOverridden(parent.getClass()))
        this.contextClassLoader = parent.getContextClassLoader();
    else
        this.contextClassLoader = parent.contextClassLoader;
    this.inheritedAccessControlContext =
            acc != null ? acc : AccessController.getContext();
    // ç›®æ ‡çº¿ç¨‹è°ƒç”¨
    this.target = target;
    // è®¾ç½®çº¿ç¨‹ä¼˜å…ˆçº§
    setPriority(priority);
    if (inheritThreadLocals && parent.inheritableThreadLocals != null)
        this.inheritableThreadLocals =
            ThreadLocal.createInheritedMap(parent.inheritableThreadLocals);
    /* Stash the specified stack size in case the VM cares */
   // çº¿ç¨‹æ ˆå¤§å°
    this.stackSize = stackSize;

    /* Set thread ID */
    // çº¿ç¨‹ID
    tid = nextThreadID();
}
```

åˆ°æ­¤ä¸€ä¸ªçº¿ç¨‹çš„æ‰€æœ‰å±æ€§åˆå§‹åŒ–å®Œæ¯•ã€‚

### çº¿ç¨‹å¯åŠ¨

çº¿ç¨‹å¯åŠ¨æ˜¯é€šè¿‡è°ƒç”¨ start() æ–¹æ³•å¯åŠ¨çš„ï¼Œçº¿ç¨‹ä» NEW çŠ¶æ€è½¬æ¢ä¸º RUNNABLEï¼Œç„¶åç”± JVM è°ƒç”¨è¯¥çº¿ç¨‹çš„ run æ–¹æ³•å»æ‰§è¡Œè¯¥çº¿ç¨‹çš„é€»è¾‘ã€‚ç›´æ¥è°ƒç”¨
run() æ–¹æ³•å°±æ˜¯æ‰§è¡Œè¯¥ç±»çš„ run() æ–¹æ³•é€»è¾‘ï¼Œå’Œè°ƒç”¨è¯¥ç±»çš„æ™®é€šæ–¹æ³•æ²¡ä»€ä¹ˆåŒºåˆ«ã€‚

æ¥çœ‹ä¸€ä¸‹è°ƒç”¨ start() æ–¹æ³•å…·ä½“åšäº†å“ªäº›æ“ä½œï¼š

```
/**
 * Causes this thread to begin execution; the Java Virtual Machine
 * calls the <code>run</code> method of this thread.
 * <p>
 * The result is that two threads are running concurrently: the
 * current thread (which returns from the call to the
 * <code>start</code> method) and the other thread (which executes its
 * <code>run</code> method).
 * <p>
 * It is never legal to start a thread more than once.
 * In particular, a thread may not be restarted once it has completed
 * execution.
 *
 * @exception  IllegalThreadStateException  if the thread was already
 *               started.
 * @see        #run()
 * @see        #stop()
 */
public synchronized void start() {
    /**
     * This method is not invoked for the main method thread or "system"
     * group threads created/set up by the VM. Any new functionality added
     * to this method in the future may have to also be added to the VM.
     *
     * A zero status value corresponds to state "NEW".
     */
     // åˆ¤æ–­çº¿ç¨‹çŠ¶æ€æ˜¯å¦å·²ç»å¯åŠ¨ï¼Œå¦‚æœå·²ç»å¯åŠ¨åˆ™æŠ›å‡ºçº¿ç¨‹çŠ¶æ€å¼‚å¸¸
    if (threadStatus != 0)
        throw new IllegalThreadStateException();

    /* Notify the group that this thread is about to be started
     * so that it can be added to the group's list of threads
     * and the group's unstarted count can be decremented. */
    // æ­¤æ—¶çº¿ç¨‹ç»„ä¸­æ‰å°†è¯¥çº¿ç¨‹æ”¾å…¥
    group.add(this);

    boolean started = false;
    try {
        // è°ƒç”¨æœ¬åœ°æ–¹æ³•å¯åŠ¨çº¿ç¨‹
        start0();
        started = true;
    } finally {
        try {
            if (!started) {
                group.threadStartFailed(this);
            }
        } catch (Throwable ignore) {
            /* do nothing. If start0 threw a Throwable then
              it will be passed up the call stack */
        }
    }
}
```

### çº¿ç¨‹ç»„æ·»åŠ çº¿ç¨‹

group.add(this); çœ‹ä¸€ä¸‹çº¿ç¨‹ç»„æ˜¯å¦‚ä½•æ·»åŠ çº¿ç¨‹çš„ï¼Œæºç å¦‚ä¸‹ï¼š

```
/**
 * Adds the specified thread to this thread group.
 *
 * <p> Note: This method is called from both library code
 * and the Virtual Machine. It is called from VM to add
 * certain system threads to the system thread group.
 *
 * @param  t
 *         the Thread to be added
 *
 * @throws  IllegalThreadStateException
 *          if the Thread group has been destroyed
 */
void add(Thread t) {
    synchronized (this) {
        // å‰ææ˜¯çº¿ç¨‹æ²¡é”€æ¯
        if (destroyed) {
            throw new IllegalThreadStateException();
        }
        // threads æ•°ç»„ä»€ä¹ˆæ—¶å€™åˆå§‹åŒ–ä¸ºå¤§å°ä¸º 4 çš„ï¼šJVM åœ¨åˆå§‹åŒ–çš„æ—¶å€™ä¼šå‘å¯åŠ¨ç»„ä¸­æ·»åŠ å®ˆæŠ¤çº¿ç¨‹
        // æ¯”è¾ƒå¥‡æ€ªçš„æ˜¯åœ¨ win ä¸Šå¯ä»¥çœ‹åˆ° 4 ä¸ªï¼Œ åœ¨ Mac ä¸Šåªèƒ½çœ‹åˆ° 3 ä¸ª

       
        if (threads == null) {
            threads = new Thread[4];
        } else if (nthreads == threads.length) {
            threads = Arrays.copyOf(threads, nthreads * 2);
        }
        threads[nthreads] = t;

        // This is done last so it doesn't matter in case the
        // thread is killed
        // å› ä¸ºå¯åŠ¨çº¿ç¨‹æ•°åŠ  1 æ˜¯æœ€åå®Œæˆçš„ï¼Œå³ä½¿çº¿ç¨‹è¢«æ€æ­»ä¹Ÿæ²¡å…³ç³»
        nthreads++;

        // The thread is now a fully fledged member of the group, even
        // though it may, or may not, have been started yet. It will prevent
        // the group from being destroyed so the unstarted Threads count is
        // decremented.
        // å› ä¸ºçº¿ç¨‹å·²ç»æ·»åŠ åˆ°çº¿ç¨‹ç»„ä¸­ï¼Œå°½ç®¡çº¿ç¨‹çŠ¶æ€ä¸ç¡®å®šæ˜¯å¦å¯åŠ¨ï¼Œä½†æ˜¯è¯¥çº¿ç¨‹å·²ç»æ˜¯çº¿ç¨‹ä¸­çš„æ­£å¼æˆå‘˜ï¼Œæ‰€ä»¥æœªå¯åŠ¨çº¿ç¨‹å‡ä¸€
        nUnstartedThreads--;
    }
}
```
å°†çº¿ç¨‹æ·»åŠ åˆ°çº¿ç¨‹ç»„ä¸­åï¼Œè°ƒç”¨æœ¬åœ° start0() æ–¹æ³•å¯åŠ¨çº¿ç¨‹ã€‚åœ¨åˆå§‹åŒ– Thread çš„æ—¶å€™ï¼Œé¦–å…ˆä¼šæœ‰ä¸€ä¸ªé™æ€åˆå§‹åŒ–çš„è¿‡ç¨‹ï¼š

```
/* Make sure registerNatives is the first thing <clinit> does. */
private static native void registerNatives();
static {
    registerNatives();
}
```

**è¿™ä¸ªæœ¬åœ°æ–¹æ³•ä¸»è¦çš„ä½œç”¨å°±æ˜¯å®Œæˆäº†è¯¥ç±»ä¸­æœ¬åœ°æ–¹æ³•çš„æ³¨å†Œã€‚è‡³äºæ³¨å†Œäº†å“ªäº›æ–¹æ³•ï¼Œä¸ºä»€ä¹ˆè¦æ³¨å†Œï¼Œæ³¨å†Œçš„ä½œç”¨**è¿˜æ²¡ç ”ç©¶ã€‚ è®°ä¸ªToDoå§ã€‚
å‚è€ƒé“¾æ¥ï¼š https://blog.csdn.net/Saintyyu/article/details/90452826

å®Œæˆæœ¬åœ°æ–¹æ³•æ³¨å†Œï¼Œç„¶åè°ƒç”¨ start0() å¯åŠ¨çº¿ç¨‹ã€‚

## å°ç»“

é€šè¿‡æºç å¯ä»¥çŸ¥é“ï¼Œå®ç° Runnable æ¥å£åˆ›å»ºçº¿ç¨‹å’Œ ç»§æ‰¿ Thread ç±»åˆ›å»ºçº¿ç¨‹çš„æ²¡ä»€ä¹ˆæœ¬è´¨åŒºåˆ«ï¼ŒThread ç±»åŒæ ·å®ç°äº† Runnable æ¥å£ï¼Œåªæ˜¯ Thread ç±»
æä¾›äº†æ›´å¤šå¯¹çº¿ç¨‹çš„å¯ç”¨æ–¹æ³•å’Œå±æ€§ã€‚

# å®ä¾‹å˜é‡å…±äº«é€ æˆçš„éçº¿ç¨‹å®‰å…¨é—®é¢˜
è‡ªå®šä¹‰çº¿ç¨‹ç±»ä¸­çš„å®ä¾‹å˜é‡é’ˆå¯¹å…¶ä»–çº¿ç¨‹å¯ä»¥åˆ†ä¸ºå¯å…±äº«å’Œä¸å…±äº«ä¸¤ç±»ã€‚è¿™åœ¨å¤šçº¿ç¨‹äº¤äº’æ—¶æ˜¯å¾ˆé‡è¦çš„æŠ€æœ¯ç‚¹ã€‚

## ä¸å…±äº«çš„æ•°æ®

è¯¥çº¿ç¨‹å†…æ‰€æ‹¥æœ‰èµ„æºå¯¹äºå…¶ä»–çº¿ç¨‹ä¸å¯è§ã€‚

### æµ‹è¯•ç”¨ä¾‹
åˆ›å»º ABC ä¸‰ä¸ªçº¿ç¨‹ï¼Œå„è‡ªä¸º ThreadVariable ç±»ä¸­çš„å˜é‡èµ‹å€¼ï¼Œç„¶åå¯åŠ¨ï¼Œä»£ç å¦‚ä¸‹ï¼š

```java
public class ThreadVariable implements Runnable{

    private int count;

    public void setCount(int count) {
        this.count = count;
    }

    @Override
    public void run() {
        while (count > 0){
            count--;
            System.out.println("ç”±" + Thread.currentThread().getName() + "è®¡ç®—ï¼Œ count=" + count);
        }
    }
}


public class ThreadTest {
    public static void main(String[] args) {
        // è®¾ç½® A çº¿ç¨‹ count
        ThreadVariable varT1 = new ThreadVariable();
        varT1.setCount(10);
        Thread t1 = new Thread(varT1);
        t1.setName("A");
        t1.start();

        ThreadVariable varT2 = new ThreadVariable();
        varT2.setCount(10);
        Thread t2 = new Thread(varT2);
        t2.setName("B");
        t2.start();

        ThreadVariable varT3 = new ThreadVariable();
        varT3.setCount(10);
        Thread t3 = new Thread(varT3);
        t3.setName("C");
        t3.start();
    }
}
```

ä¸€å…±åˆ›å»ºäº†ä¸‰ä¸ªçº¿ç¨‹ï¼Œæ¯ä¸ªçº¿ç¨‹éƒ½æ‹¥æœ‰è‡ªå·±çš„ count å˜é‡ï¼Œè‡ªå·±å‡å°‘è‡ªå·±çš„countå˜é‡ï¼Œå½¼æ­¤äº’ä¸å…±äº«ï¼Œã€‚

## å…±äº«çš„æ•°æ®

å…±äº«æ•°æ®çš„æƒ…å†µæ˜¯å¤šä¸ªçº¿ç¨‹å…±åŒè®¿é—®ä¸€ä¸ªå˜é‡ã€‚æ¯”è¾ƒå…¸å‹çš„åœºæ™¯æ˜¯å¤šä¸ªçº¿ç¨‹å…±åŒå¤„ç†ä¸€ä¸ªäººçš„ç¥¨æ•°ï¼Œå³å¤šç”¨æˆ·é€šè¿‡çº¿ä¸Šç»™æŸä¸€ä¸ªäººæŠ•ç¥¨ï¼Œè®¡æ•°ã€‚

ç”¨ä¸Šè¿°ä¾‹å­ï¼Œå°† count æ”¾åˆ° while å¾ªç¯ä¹‹å¤–ï¼Œç„¶ååˆ›å»ºå¤šä¸ªçº¿ç¨‹ï¼Œæ‰§è¡Œã€‚

æµ‹è¯•ä»£ç å¦‚ä¸‹ï¼š

```
System.out.println("=======================çº¿ç¨‹å˜é‡å…±äº« start=====================");
ThreadVariableShare varT4 = new ThreadVariableShare();
varT4.setCount(10);
Thread t4 = new Thread(varT1);
t4.setName("varT4");
t4.start();

ThreadVariableShare varT5 = new ThreadVariableShare();
Thread t5 = new Thread(varT2);
t5.setName("varT5");
t5.start();

ThreadVariableShare varT6 = new ThreadVariableShare();
Thread t6 = new Thread(varT3);
t6.setName("varT6");
t6.start();
System.out.println("=======================çº¿ç¨‹å˜é‡å…±äº« end=====================");
```
ä»”ç»†è§‚å¯Ÿæ‰“å°ç»“æœä¼šå‘ç°ï¼Œcount ä¼šæœ‰ç›¸åŒçš„å€¼è¢«ä¸åŒçš„çº¿ç¨‹æ‰“å°å‡ºæ¥ï¼Œè¿™æ ·å°±äº§ç”Ÿäº† "éçº¿ç¨‹å®‰å…¨" é—®é¢˜ï¼Œæ­£å¸¸æƒ…å†µä¸‹ï¼Œcount çš„è¾“å‡ºå€¼å› è¯¥æ˜¯é€’å‡çš„ï¼Œ
è€Œä¸åº”è¯¥æ˜¯é‡å¤çš„ã€‚

å‡ºç°é‡å¤å€¼æ˜¯å› ä¸ºåœ¨æŸäº› JVM ä¸­ï¼Œcount-- æ“ä½œè¦åˆ†è§£æˆå¦‚ä¸‹ 3 æ­¥(è€Œæ‰§è¡Œè¿™ 3 ä¸ªæ­¥éª¤çš„è¿‡ç¨‹ä¸­ä¼šè¢«å…¶ä»–çº¿ç¨‹æ‰“æ–­)ï¼š

1. å–å¾—åŸæœ‰ count å€¼ï¼›
2. è®¡ç®— count - 1ï¼›
3. å¯¹ count èµ‹å€¼ï¼›

è¿™ä¸‰æ­¥ä»»æ„ä¸€æ­¥éƒ½å¯èƒ½è¢«å…¶ä»–çº¿ç¨‹æ‰“æ–­ï¼Œä»è€Œé€ æˆå–å¾— count å€¼çš„ç»“æœä¸ä¸€è‡´ã€‚

ä¹¦ä¸­è¿˜ä»‹ç»äº†ä¸€ä¸ªæ¯”è¾ƒå…¸å‹çš„æ¡ˆä¾‹ï¼šServlet æŠ€æœ¯é€ æˆçš„éçº¿ç¨‹å®‰å…¨é—®é¢˜ä¸è§£å†³æ–¹æ¡ˆï¼š

éçº¿ç¨‹å®‰å…¨é—®é¢˜ä¸»è¦æ˜¯æŒ‡å¤šä¸ªçº¿ç¨‹å¯¹åŒä¸€ä¸ªå¯¹è±¡ä¸­çš„åŒä¸€ä¸ªå®ä¾‹å˜é‡è¿›è¡Œæ“ä½œæ—¶ä¼šå‡ºç°å€¼è¢«æ›´æ”¹ã€å€¼ä¸åŒæ­¥çš„æƒ…å†µï¼Œè¿›è€Œå½±å“ç¨‹åºçš„æ‰§è¡Œæµç¨‹ã€‚
ä»£ç å¦‚ä¸‹ï¼š

æ¨¡æ‹Ÿå®ç°ä¸€ä¸ªç»„ä»¶
```
/**
 * æ¨¡æ‹Ÿä¸€ä¸ª servlet ç™»é™†ç»„ä»¶
 */
public class ThreadServletLogin {
    private static String usernameRef;
    private static String passwordRef;

    public static void doPost(String username, String password){
        usernameRef = username;
        if(username.equals("a")){
            try {
                Thread.sleep(5000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        passwordRef = password;
        System.out.println("username= " + usernameRef + " password= " + passwordRef);
    }
}
```

åˆ›å»ºä¸¤ä¸ªçº¿ç¨‹æ¨¡æ‹Ÿç™»é™†
```
public class ThreadServletLoginA  extends Thread{
    @Override
    public void run() {
        ThreadServletLogin.doPost("a", "LoginA");
    }
}

public class ThreadServletLoginB extends Thread{
    @Override
    public void run() {
        ThreadServletLogin.doPost("b", "Loginb");
    }
}
```

æµ‹è¯•ç±»
```
public class ThreadServletLoginTest {
    public static void main(String[] args) {
        ThreadServletLoginA aLogin = new ThreadServletLoginA();
        aLogin.start();
        ThreadServletLoginB bLogin = new ThreadServletLoginB();
        bLogin.start();
    }
}
```

è¾“å‡ºç»“æœå°±ä¼šå‡ºç°ä»¥ä¸‹å‡ ç§æƒ…å†µï¼š
```
a bb
a aa
------
b aa
b bb
```

ToDo: åç»­ç« èŠ‚å†ä»‹ç»å¦‚ä½•è§£å†³è¿™ç§ "éçº¿ç¨‹å®‰å…¨é—®é¢˜" ã€‚ä¸‹é¢æ¥çœ‹ä¸€ä¸‹ Thread ç±»æä¾›çš„

# Thread æä¾›çš„æ–¹æ³•

## currentThread() æ–¹æ³•

è¯¥æ–¹æ³•å¯ä»¥è¿”å›ä»£ç æ®µæ­£åœ¨è¢«é‚£ä¸ªçº¿ç¨‹è°ƒç”¨ã€‚é€šè¿‡è¯¥æ–¹æ³•å¯ä»¥éªŒè¯ä¸€ä¸‹ä½¿ç”¨ start å¯åŠ¨çº¿ç¨‹å’Œç›´æ¥è°ƒç”¨ run æ–¹æ³•çš„ä¸åŒ.
æµ‹è¯•ç±»ï¼š
```
public class CurrentThreadMethod extends Thread{

    public CurrentThreadMethod(){
        System.out.println("æ„é€ æ–¹æ³•çš„æ‰“å°ï¼Œå½“å‰çº¿ç¨‹æ‰§è¡Œåç§°ï¼š: " + Thread.currentThread().getName());
    }

    @Override
    public void run() {
        System.out.println("run æ–¹æ³•æ‰“å°, å½“å‰çº¿ç¨‹æ‰§è¡Œåç§°ï¼š" + Thread.currentThread().getName());
    }
}


public class ThreadMethod {
    public static void main(String[] args) {
        CurrentThreadMethod currentThreadMethod = new CurrentThreadMethod();
        Thread t = new Thread(currentThreadMethod);
        t.start();
        t.run();

    }
}

// è¾“å‡ºç»“æœ

æ„é€ æ–¹æ³•çš„æ‰“å°ï¼Œå½“å‰çº¿ç¨‹æ‰§è¡Œåç§°ï¼š: main
run æ–¹æ³•æ‰“å°, å½“å‰çº¿ç¨‹æ‰§è¡Œåç§°ï¼šmain
run æ–¹æ³•æ‰“å°, å½“å‰çº¿ç¨‹æ‰§è¡Œåç§°ï¼šThread-1
```

1. è§‚å¯Ÿè¾“å‡ºç»“æœèƒ½çœ‹åˆ° ç›´æ¥è°ƒç”¨ run æ–¹æ³•æ˜¯ç”± main è°ƒç”¨çš„ï¼Œå¹¶æ²¡æœ‰å¯åŠ¨ä¸€ä¸ªçº¿ç¨‹ï¼Œä½¿ç”¨ start è°ƒç”¨åˆ™æ˜¯å¯åŠ¨äº†ä¸€ä¸ªæ–°çš„çº¿ç¨‹ï¼›
2. ç›´æ¥è°ƒç”¨ run æ–¹æ³•æ˜¯ç«‹å³æ‰§è¡Œçš„ï¼Œ t.start() åˆ™æ˜¯éœ€è¦ç­‰å¾… CPU è°ƒåº¦ï¼Œç„¶åæ‰§è¡Œã€‚

### this.getName() å’Œ currentThread.getName()

currentThread.getName()æ–¹æ³•: è¿”å›å½“å‰ä»£ç æ®µæ­£åœ¨è¢«é‚£ä¸ªçº¿ç¨‹è°ƒç”¨ï¼›

this.getName()æ–¹æ³•ï¼šè·å–å½“å‰å¯¹è±¡çš„åå­—ï¼Œåªæ˜¯å•çº¯çš„æ–¹æ³•è°ƒç”¨ï¼›

```
public class CurrentThreadMethod extends Thread{

    public CurrentThreadMethod(){
        System.out.println("æ„é€ æ–¹æ³•çš„æ‰“å°ï¼Œå½“å‰çº¿ç¨‹æ‰§è¡Œåç§°ï¼š: " + Thread.currentThread().getName());
        System.out.println("æ„é€ æ–¹æ³•çš„æ‰“å°ï¼Œå½“å‰ç±»çš„åç§°ï¼š" + this.getName());
    }

    @Override
    public void run() {
        System.out.println("run æ–¹æ³•æ‰“å°, å½“å‰çº¿ç¨‹æ‰§è¡Œåç§°ï¼š" + Thread.currentThread().getName());
        System.out.println("run æ–¹æ³•æ‰“å°ï¼Œå½“å‰ç±»çš„åç§°" + this.getName());
    }
}

public class ThreadMethod {
    public static void main(String[] args) {
        CurrentThreadMethod currentThreadMethod = new CurrentThreadMethod();
        Thread t = new Thread(currentThreadMethod);
        t.setName("æ‰§è¡Œçº¿ç¨‹A");
        t.start();
        t.run();

    }
}

// è¾“å‡ºç»“æœ
æ„é€ æ–¹æ³•çš„æ‰“å°ï¼Œå½“å‰çº¿ç¨‹æ‰§è¡Œåç§°ï¼š: main
æ„é€ æ–¹æ³•çš„æ‰“å°ï¼Œå½“å‰ç±»çš„åç§°ï¼šThread-0
run æ–¹æ³•æ‰“å°, å½“å‰çº¿ç¨‹æ‰§è¡Œåç§°ï¼šmain
run æ–¹æ³•æ‰“å°ï¼Œå½“å‰ç±»çš„åç§°Thread-0
run æ–¹æ³•æ‰“å°, å½“å‰çº¿ç¨‹æ‰§è¡Œåç§°ï¼šæ‰§è¡Œçº¿ç¨‹A
run æ–¹æ³•æ‰“å°ï¼Œå½“å‰ç±»çš„åç§°Thread-0
```
this.getName() ä»£è¡¨çš„æ˜¯ CurrentThreadMethod å¯¹è±¡çš„åç§°, åªæ˜¯å•çº¯çš„æ–¹æ³•è°ƒç”¨ï¼Œæ²¡æœ‰é‡å†™è¿™ä¸ªæ–¹æ³•ï¼Œæ‰€ä»¥è°ƒç”¨çš„æ˜¯çˆ¶ç±» Thread æ–¹æ³•ï¼Œåˆå§‹åŒ– 
CurrentThreadMethod çš„ name åç§° Thread-0ï¼›

t.setName() çš„ name æ˜¯ Thread å¯¹è±¡ï¼Œå¹¶ä¸ä¼šå½±å“ CurrentThreadMethod çš„ name å±æ€§

## isAlive() æ–¹æ³•

isAlive() æ–¹æ³•çš„åŠŸèƒ½æ˜¯åˆ¤æ–­å½“å‰çš„çº¿ç¨‹æ˜¯å¦å­˜æ´»ã€‚
```
public class ThreadisAliveMethod extends Thread{
    @Override
    public void run() {
        System.out.println("run=" + Thread.currentThread().isAlive());
    }
}


ThreadisAliveMethod threadisAliveMethod = new ThreadisAliveMethod();
System.out.println("threadisAliveMethod çº¿ç¨‹çŠ¶æ€ start ï¼š" + threadisAliveMethod.isAlive());
threadisAliveMethod.start();
System.out.println("threadisAliveMethod çº¿ç¨‹çŠ¶æ€ endï¼š" + threadisAliveMethod.isAlive());

// è¾“å‡ºç»“æœ
threadisAliveMethod çº¿ç¨‹çŠ¶æ€ start ï¼šfalse
threadisAliveMethod çº¿ç¨‹çŠ¶æ€ endï¼štrue
run=true
```

æ³¨æ„è¿™é‡Œ end=true æ˜¯ä¸ç¡®å®šçš„ï¼Œå› ä¸ºåœ¨æ‰§è¡Œæ‰“å° end çš„æ—¶å€™ï¼Œçº¿ç¨‹å¯èƒ½æœªç»“æŸï¼Œå› è€Œ end=trueã€‚å¦‚æœæ”¹å°†ä»£ç æ›´æ”¹ä¸€ä¸‹ï¼š
```
ThreadisAliveMethod threadisAliveMethod = new ThreadisAliveMethod();
System.out.println("threadisAliveMethod çº¿ç¨‹çŠ¶æ€ start ï¼š" + threadisAliveMethod.isAlive());
threadisAliveMethod.start();
try {
    Thread.sleep(1000);
} catch (InterruptedException e) {
    //doNothing
}
System.out.println("threadisAliveMethod çº¿ç¨‹çŠ¶æ€ endï¼š" + threadisAliveMethod.isAlive());

// è¾“å‡ºç»“æœ
threadisAliveMethod çº¿ç¨‹çŠ¶æ€ start ï¼šfalse
run=true
threadisAliveMethod çº¿ç¨‹çŠ¶æ€ endï¼šfalse
```

Thread.sleep(1000) æ˜¯è®© main çº¿ç¨‹åœæ­¢ 1 ç§’ï¼Œè¿‡ 1s å threadisAliveMethod çº¿ç¨‹æ‰§è¡Œå®Œæˆï¼Œæ­¤æ—¶è¯¥çº¿ç¨‹çŠ¶æ€ end = trueã€‚

### this.isAlive() å’Œ currentThread.isAlive()

å½“å°†çº¿ç¨‹å¯¹è±¡ä»¥æ„é€ å‚æ•°çš„æ–¹å¼ä¼ é€’ç»™ Thread å¯¹è±¡è¿›è¡Œ start å¯åŠ¨æ—¶ï¼Œè¿è¡Œçš„ç»“æœä¸å‰é¢æ˜¯æœ‰å·®å¼‚çš„ã€‚ç¤ºä¾‹å¦‚ä¸‹ï¼š

```
public class ThreadisAliveMethod extends Thread{

    public ThreadisAliveMethod() {
        System.out.println("ThreadisAliveMethod-------------begin");
        System.out.println("Thread.currentThread.getName=" + Thread.currentThread().getName());
        System.out.println("currentThread.isAlive=" + Thread.currentThread().isAlive());
        System.out.println("this.getName()=" + this.getName());
        System.out.println("this.isAlive=" + this.isAlive());
        System.out.println("ThreadisAliveMethod-------------end");

    }

    @Override
    public void run() {
        System.out.println("run-------------begin");
        System.out.println("Thread.currentThread.getName=" + Thread.currentThread().getName());
        System.out.println("currentThread.isAlive=" + Thread.currentThread().isAlive());
        System.out.println("thi.getName()=" + this.getName());
        System.out.println("this.isAlive=" + this.isAlive());
        System.out.println("run-------------end");
    }
}

ThreadisAliveMethod aliveMethod = new ThreadisAliveMethod();
Thread t2 = new Thread(aliveMethod);
System.out.println("t2 çº¿ç¨‹çŠ¶æ€ start ï¼š" + t2.isAlive());
t2.setName("aliveThread");
t2.start();
System.out.println("t2 çº¿ç¨‹çŠ¶æ€ endï¼š" + t2.isAlive());


è¾“å‡ºç»“æœï¼š
ThreadisAliveMethod-------------begin
Thread.currentThread.getName=main
currentThread.isAlive=true
thi.getName()=Thread-0
this.isAlive=false
ThreadisAliveMethod-------------end
t2 çº¿ç¨‹çŠ¶æ€ start ï¼šfalse
t2 çº¿ç¨‹çŠ¶æ€ endï¼štrue
run-------------begin
Thread.currentThread.getName=aliveThread
currentThread.isAlive=true
thi.getName()=Thread-0
this.isAlive=false
run-------------end
```
å½“æˆ‘ä»¬å°†çº¿ç¨‹å¯¹è±¡ä»¥æ„é€ å‚æ•°çš„å½¢å¼ä¼ é€’ç»™ Thread å¯¹è±¡è¿›è¡Œ start å¯åŠ¨ï¼Œä½¿ç”¨ Thread.currentThread å’Œ this ä»£è¡¨çš„å¯¹è±¡æ˜¯ä¸ä¸€æ ·çš„ã€‚å› ä¸ºæˆ‘ä»¬å°†çº¿ç¨‹
å¯¹è±¡ä½œä¸ºæ„é€ å‚æ•°ä¼ é€’ç»™ Thread ç±»ï¼Œç„¶åä½¿ç”¨ Thread æ–¹æ³• start å¯åŠ¨çº¿ç¨‹ï¼Œç„¶åæ‰§è¡Œçš„æ˜¯ä¼ é€’çš„çº¿ç¨‹å¯¹è±¡çš„ run æ–¹æ³•ï¼Œæ‰€ä»¥ this.isAlive() è·å–çš„æ˜¯
æ²¡æœ‰è¢«å¯åŠ¨çš„çº¿ç¨‹å¯¹è±¡ä¿¡æ¯ï¼Œè€Œä½¿ç”¨Thread.currentThread() è·å–çš„å¾—åˆ™æ˜¯è°ƒç”¨è¿™æ®µä»£ç çš„çº¿ç¨‹ä¿¡æ¯ï¼Œå³ Thread ä¿¡æ¯ã€‚æ‰€ä»¥æœ¬æ¬¡ç¤ºä¾‹çš„ç»“æœæ‰ä¸å‰é¢çš„ç¤ºä¾‹ç»“æœ
æœ‰å·®å¼‚ã€‚

## sleep(long millis) æ–¹æ³•
sleep æ–¹æ³•çš„ä½œç”¨æ˜¯åœ¨æŒ‡å®šæ—¶é—´(æ¯«ç§’)å†…è®©å½“å‰æ­£åœ¨æ‰§è¡Œçš„çº¿ç¨‹ä¼‘çœ (æš‚åœæ‰§è¡Œ), è¿™ä¸ªæ­£åœ¨æ‰§è¡Œçš„çº¿ç¨‹æ˜¯æŒ‡ this.currentThread() è¿”å›çš„çº¿ç¨‹ã€‚

```
public class ThreadSleepMethod extends Thread{
    @Override
    public void run() {
        System.out.println("run threadName = " + this.currentThread().getName() + "begin");
        try {
            this.sleep(2000);
            System.out.println("run threadName = "+ currentThread().getName() + "end");
        } catch (InterruptedException e) {
            // doNothing
        }
    }
}

// ç›´æ¥è°ƒç”¨ runæ–¹æ³•
ThreadSleepMethod threadSleepMethod = new ThreadSleepMethod();
System.out.println("begin----------------" + System.currentTimeMillis());
threadSleepMethod.run();
System.out.println("end------------------" + System.currentTimeMillis());
```

å½“è°ƒç”¨ sleep() æ–¹æ³•æ˜¯æ‰€åœ¨ç±»æ˜¯ Thread æ—¶ï¼Œåˆ™æ‰§è¡Œä»£ç  this.sleep() å’Œ Thread.sleep() æ•ˆæœæ˜¯ä¸€æ ·çš„ï¼Œç»“æœå¦‚ä¸‹ï¼š
```
// this.sleep() ç»“æœ
begin----------------1647745747085
run threadName = mainbegin
run threadName = mainend
end------------------1647745749090èŠ±è´¹æ—¶é—´ä¸º=2s
// Thread.sleep()
begin----------------1647745810897
run threadName = mainbegin
run threadName = mainend
end------------------1647745812901èŠ±è´¹æ—¶é—´ä¸º=2s
```
å¯åŠ¨çº¿ç¨‹æµ‹è¯•ï¼š
```
long start2 = System.currentTimeMillis();
ThreadSleepMethod sleepMethod = new ThreadSleepMethod();
System.out.println("begin----------------" + start2);
sleepMethod.start();
System.out.println("end------------------" + System.currentTimeMillis() + "èŠ±è´¹æ—¶é—´ä¸º=" +(System.currentTimeMillis() - start2)/1000 + "s");

// è¾“å‡ºç»“æœï¼š
begin----------------1647745985861
end------------------1647745985862èŠ±è´¹æ—¶é—´ä¸º=0s
run threadName = Thread-0begin
run threadName = Thread-0end
```
ç”±äº main çº¿ç¨‹ä¸ sleepMethod å¼‚æ­¥ï¼ŒsleepMethod æš‚åœ 2s æ‰§è¡Œï¼Œæ‰€ä»¥é¦–å…ˆè¾“å‡º main çº¿ç¨‹æ‰“å°çš„ä¿¡æ¯ï¼Œ2s åè¾“å‡º sleepMethod ä¿¡æ¯

### sleep(long millis, int nanos) æ–¹æ³•

è¯¥æ–¹æ³•çš„ä½œç”¨æ˜¯åœ¨æŒ‡å®šçš„æ¯«ç§’æ•°åŠ æŒ‡å®šçš„çº³ç§’æ•°å†…è®©å½“å‰æ­£åœ¨æ‰§è¡Œçš„çº¿ç¨‹ä¼‘çœ ï¼Œæ­¤æ“ä½œç³»ç»Ÿå—åˆ°ç³»ç»Ÿè®¡æ—¶å™¨å’Œè°ƒåº¦ç¨‹åºçš„ç²¾å‡†åº¦å’Œå‡†ç¡®æ€§çš„å½±å“ã€‚

```
// sleep(long millis, int nanos)
long start3 = System.currentTimeMillis();
System.out.println("begin----------------" + start3);
try {
    Thread.sleep(2000, 999999);
} catch (InterruptedException e) {
    e.printStackTrace();
}
System.out.println("end------------------" + System.currentTimeMillis() + "èŠ±è´¹æ—¶é—´ä¸º=" +(System.currentTimeMillis() - start3) + "ms");

// è¾“å‡ºç»“æœï¼š
begin----------------1647748698686
end------------------1647748700690èŠ±è´¹æ—¶é—´ä¸º=2004ms
```
å¯ä»¥çœ‹åˆ° ns çº§çº¿ç¨‹çš„ä¼‘çœ æ—¶é—´å¹¶ä¸æ˜¯é‚£ä¹ˆå‡†ç¡®äº†ã€‚

## getStackTrace() æ–¹æ³•

è¯¥æ–¹æ³•çš„ä½œç”¨æ˜¯è¿”å›ä¸€ä¸ªè¡¨ç¤ºè¯¥è¯¥çº¿ç¨‹å †æ ˆè·Ÿè¸ªå…ƒç´ æ•°ç»„ã€‚å¦‚æœçº¿ç¨‹å°šæœªå¯åŠ¨æˆ–è€…å·²ç»ç»ˆæ­¢ï¼Œåˆ™è¯¥æ–¹æ³•å°†è¿”å›ä¸€ä¸ª 0 é•¿åº¦æ•°ç»„ã€‚å¦åˆ™æ•°ç»„ä¸­ç¬¬ä¸€ä¸ªå…ƒç´ ä»£è¡¨
å †æ ˆé¡¶ï¼Œå®ƒæ˜¯è¯¥æ•°ç»„ä¸­æœ€æ–°çš„æ–¹æ³•è°ƒç”¨ï¼›æœ€åä¸€ä¸ªå…ƒç´ ä»£è¡¨å †æ ˆåº•ï¼Œæ˜¯è¯¥æ•°ç»„ä¸­æœ€å¼€å§‹çš„æ–¹æ³•è°ƒç”¨ã€‚æµ‹è¯•ä»£ç å¦‚ä¸‹ï¼š

```
public class GetStackTraceThreadMethod extends Thread{

    private void a(){
        b();
    }

    private void b(){
        c();
    }

    private void c(){
        d();
    }

    private void d(){
        e();
    }

    private void e(){
        StackTraceElement[]  elementArray = Thread.currentThread().getStackTrace();
        if(elementArray != null){
            for (StackTraceElement element : elementArray) {
                System.out.println("className= " + element.getClassName() + "\nmethodName= " + element.getMethodName() +
                        "\nfileName= " + element.getFileName() + "\nlineNumber= " + element.getLineNumber());
            }
        }else{
            System.out.println("çº¿ç¨‹æ²¡æœ‰å¯åŠ¨");
        }

        StackTraceElement[]  elementArray2 = this.getStackTrace();
        System.out.println("å½“å‰çº¿ç¨‹ç±» GetStackTraceThreadMethod å¤§å°ä¸º= " + elementArray2.length);
        if(elementArray2 != null){
            for (StackTraceElement element : elementArray2) {
                System.out.println("className= " + element.getClassName() + "\nmethodName= " + element.getMethodName() +
                        "\nfileName= " + element.getFileName() + "\nlineNumber= " + element.getLineNumber());
            }
        }else{
            System.out.println("çº¿ç¨‹æ²¡æœ‰å¯åŠ¨");
        }
    }

    @Override
    public void run() {
        System.out.println("run---------------------------start");
        a();
        System.out.println("run---------------------------end");
    }
}

public class GetStackTraceThreadMethodTest {
    
    public static void main(String[] args) {
//        // ç›´æ¥å¯åŠ¨çº¿ç¨‹
//        GetStackTraceThreadMethod stackTraceThreadMethod = new GetStackTraceThreadMethod();
//        stackTraceThreadMethod.setName("getStackTrace");
//        stackTraceThreadMethod.start();

        // ä½œä¸ºæ„é€ å‚æ•°ä¼ å…¥
        GetStackTraceThreadMethod stackTraceThreadMethod1 = new GetStackTraceThreadMethod();
        Thread t= new Thread(stackTraceThreadMethod1);
        t.setName("getStackTrace2");
        t.start();
    }
}

è¾“å‡ºç»“æœï¼š
run---------------------------start
className= java.lang.Thread
methodName= getStackTrace
fileName= Thread.java
lineNumber= 1559
className= com.anzhi.threadmethod.getstacktrace.GetStackTraceThreadMethod
methodName= e
fileName= GetStackTraceThreadMethod.java
lineNumber= 23
className= com.anzhi.threadmethod.getstacktrace.GetStackTraceThreadMethod
methodName= d
fileName= GetStackTraceThreadMethod.java
lineNumber= 19
className= com.anzhi.threadmethod.getstacktrace.GetStackTraceThreadMethod
methodName= c
fileName= GetStackTraceThreadMethod.java
lineNumber= 15
className= com.anzhi.threadmethod.getstacktrace.GetStackTraceThreadMethod
methodName= b
fileName= GetStackTraceThreadMethod.java
lineNumber= 11
className= com.anzhi.threadmethod.getstacktrace.GetStackTraceThreadMethod
methodName= a
fileName= GetStackTraceThreadMethod.java
lineNumber= 7
className= com.anzhi.threadmethod.getstacktrace.GetStackTraceThreadMethod
methodName= run
fileName= GetStackTraceThreadMethod.java
lineNumber= 48
className= java.lang.Thread
methodName= run
fileName= Thread.java
lineNumber= 748
å½“å‰çº¿ç¨‹ç±» GetStackTraceThreadMethod å¤§å°ä¸º= 0
run---------------------------end
```













