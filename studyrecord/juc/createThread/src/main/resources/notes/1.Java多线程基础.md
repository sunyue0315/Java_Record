# Java 多线程
在线程这个概念提出之前，在操作系统中只有进程的概念。进程是操作系统结构的基础；是一次程序的执行。是系统进行资源分配和
调度的一个独立单位。

程序是指序列指令，这些指令可以让 CPU 按照人类指令完成相应的任务。在操作系统中启动一个 JVM 虚拟机就相当于创建了一个进程。

那什么是线程呢？线程是进程中独立运行的子任务，可以共享进程中相同的内存或文件资源。

# Java 线程的使用

## 继承 Thread 类

Java JDK 中包含了对多线程技术的支持。实现多线程编程主要有两种方式：

1. 继承 Thread 类；

2. 实现 Runnable 接口

### 继承 Thread 类

```java
public class CreateThreadByExtendsThread extends Thread{
    @Override
    public void run() {
        super.run();
        System.out.println("Create Thread by Extends Thread Begin to Run!");
    }
}
```


```java
public class ThreadTest {
    public static void main(String[] args) {
        CreateThreadByExtendsThread t = new CreateThreadByExtendsThread();
        t.setName("CreateThreadByExtendsThread"); // 指定线程执行名称
        t.start();  // 耗时较长
        System.out.println("当前线程" + Thread.currentThread().getName() + "执行结束\n" + "当前线程" + t.getName() + "执行结束"); //主线程耗时较短
    }
}
```

多次执行的结果，仔细观察就会发现，输出结果并不是随着调用顺序而输出的。而程序中执行 start方法比较耗时是因为该方法执行了多个步骤。步骤如下：

1. 通过 JVM 告诉操作系统创建 Thread；

2. 通过操作系统开辟内存并使用操作系统 SDK 中的 createThread() 函数创建 Thread 线程对象；

3. 操作系统对 Thread 对象进行调度，以确定执行时机；

4. Thread 在操作系统中被执行成功

以上4个步骤执行完成消耗的时间一定大于 main 方法中的输出时间。而且 main 方法执行 start() 方法时不需要等4个步骤都执行完毕，而是继续执行 start()
方法后面的代码，如果在主线程中直接调用 run 方法，输出顺序就是按照代码顺序输出，此时的 run 方法是由主线程调用的，所以才会按照代码顺序执行。

多线程随机输出的原因是 CPU 将时间片分给不同的线程，线程获得时间片后就开始执行任务，线程获得时间片是随机的，执行输出的顺序自然也是乱序的。

## 实现 Runnable 接口

如果想创建的线程类已经有了一个父类了，那么就不能再继承 Thread 类，此时就需要实现 Runnable 接口来解决这样的问题。

```java
public class CreateThreadByRunnable implements Runnable{

    @Override
    public void run() {
        System.out.println("Create Thread by implements Runnable Begin to Run!");
    }
}
```

```
public class ThreadTest {
    public static void main(String[] args) {
        CreateThreadByRunnable runnable = new CreateThreadByRunnable();
        Thread t2 = new Thread(runnable);
        t2.setName("CreateThreadByRunnable");
        t2.start();  // 耗时较长
        System.out.println("当前线程" + Thread.currentThread().getName() + "执行结束\n" + "当前线程" + t2.getName() + "执行结束"); //主线程耗时较短
    }
}
```

### 使用 Runnable 接口实现多线程的优点

使用继承 Thread 类的方式实现多线程在程序设计上是有局限性的，这是由 Java 本身不支持多继承导致的。为了解决这样的局限性，因此采用实现 Runnable
接口来实现多线程的开发

在 Thread.java 类中也实现了 Runnable 接口。

```java
public
class Thread implements Runnable {
    /* Make sure registerNatives is the first thing <clinit> does. */
    private static native void registerNatives();

    static {
        registerNatives();
    }
    //...省略
}
```

测试代码如下：

```
public class ThreadTest {
    public static void main(String[] args) {
        CreateThreadByExtendsThread t = new CreateThreadByExtendsThread();
        t.setName("CreateThreadByExtendsThread"); // 指定线程执行名称
        t.start();  // 耗时较长
        System.out.println("当前线程" + Thread.currentThread().getName() + "执行结束\n" + "当前线程" + t.getName() + "执行结束"); //主线程耗时较短
        
        // CreateThreadByExtendsThread 是 Thread 子类，
        // Thread 是 Runnable 子类，所以 CreateThreadByExtendsThread 相当于 Thread 的实现类
        // 所以构造函数可以传入一个 Thread 类，这样完全可以将 Thread 类对象中的 run 方法交由其他线程调用
        
        Thread t3 = new Thread(t);
        t3.setName("测试Thread可以传入Runnable接口");
        t3.start();
    }
}
```

# 实现 Runnable 接口与继承 Thread 类的内部流程

## Thread执行流程：

![Thread执行流程](../图片/1.extendsThreadExecuteProccess.png)

创建线程的时候可以为线程指定名字，如果没有指定，线程在创建的时候会自动为它生成名字。这个操作在 Thread 的无参构造中。在无参构造函数中创建
还调用了 init 方法，完成对线程属性的初始化。源码如下：

```
/**
 * Allocates a new {@code Thread} object. This constructor has the same
 * effect as {@linkplain #Thread(ThreadGroup,Runnable,String) Thread}
 * {@code (null, null, gname)}, where {@code gname} is a newly generated
 * name. Automatically generated names are of the form
 * {@code "Thread-"+}<i>n</i>, where <i>n</i> is an integer.
 */
public Thread() {
    init(null, null, "Thread-" + nextThreadNum(), 0);
}
```

### Thread 属性

init 方法完成对线程属性的初始化，了解一下 Thread 类包含了哪些属性：

```
private volatile String name; // 线程名称
private int            priority; // 线程优先级 (ToDo : 有多少级)
private boolean     single_step; // 线程是否单步执行 默认 false
private boolean     daemon = false; // 线程是否为守护线程(ToDo: 什么是守护线程)
private boolean     stillborn = false; // 虚拟机状态 (ToDo 2: 有哪些，有什么作用)

private Runnable target; // 最终线程的逻辑执行是通过 target 调用执行
private ThreadGroup group; // 线程组(ToDo: 线程组的作用)
private ClassLoader contextClassLoader; // 此线程的 ClassLoader(类加载器)

private AccessControlContext inheritedAccessControlContext; // 当前线程继承的权限：控制上下文、以及安全机制相关(未来可能被废弃)
private static int threadInitNumber; // 自动编号匿名线程 即没有主动命名的线程
ThreadLocal.ThreadLocalMap threadLocals = null;; // 此线程的本地变量值.此map由ThreadLocal类进行维护,因为这个类在ThreadLocal中是包级私有的, ThreadLocalMap 是一个用于维护线程本地变量的 hashMao
ThreadLocal.ThreadLocalMap inheritableThreadLocals = null; // 此线程继承拥有的本地变量值，即 A 线程继承 B线程称， 那么 B 线程中 threadLocals 维护的变量在存放到这 inheritableThreadLocals 中


private long stackSize;  //此线程请求的堆栈大小，如果创建者未指定堆栈大小，则为 0。最终由虚拟指定(人为指定会不会生效)；一些虚拟机会忽略它。
private long nativeParkEventPointer; //在本机线程终止后持续存在的 JVM 私有状态 (ToDo: 不知道有什么作用)
private long tid; 线程 ID
private static long threadSeqNumber; // 用于生成线程 ID
private volatile int threadStatus = 0; // (ToDo: 线程有哪些状态 0: 表示未启动)
volatile Object parkBlocker; // 提供给当前调用 java.util.concurrent.locks.LockSupport.park 的参数。由（私有）java.util.concurrent.locks.LockSupport.setBlocker 设置使用， 由java.util.concurrent.locks.LockSupport.getBlocker 访问
private volatile Interruptible blocker; // 当前线程在可中断的 I/O 操作中处于阻塞状态时，在设置了对象的 interrupt 状态后，必须调用这个对象的 interrupt 方法(ToDo: 后面了解一下)
public final static int MIN_PRIORITY = 1; // 线程具备的最低优先级
public final static int NORM_PRIORITY = 5; // 分配给线程默认的优先级，这里的优先级是一个天花板，而不是一个记录尺
public final static int MAX_PRIORITY = 10; // 线程拥有的最大优先级 10 
```

Thread 的所有属性作用和使用场景，以及变量前面的修饰符了解下。后面再深入研究吧。😆

### init 初始化

```
public Thread() {
    init(null, null, "Thread-" + nextThreadNum(), 0);
}
```

nextThreadNum() 函数源码: 生成当前线程 ID
```
private static synchronized int nextThreadNum() {
    return threadInitNumber++;
}
```
在 init 方法调用了 重载实现的 init方法，源码如下：
```text
/**
 * Initializes a Thread with the current AccessControlContext.
 * @see #init(ThreadGroup,Runnable,String,long,AccessControlContext,boolean)
 */
private void init(ThreadGroup g, Runnable target, String name,
                  long stackSize) {
    init(g, target, name, stackSize, null, true);
}
```

#### 线程初始化核心

```
/**
 * Initializes a Thread.
 *
 * @param g the Thread group
 * @param target the object whose run() method gets called
 * @param name the name of the new Thread
 * @param stackSize the desired stack size for the new thread, or
 *        zero to indicate that this parameter is to be ignored.
 * @param acc the AccessControlContext to inherit, or
 *            AccessController.getContext() if null
 * @param inheritThreadLocals if {@code true}, inherit initial values for
 *            inheritable thread-locals from the constructing thread
 */
private void init(ThreadGroup g, Runnable target, String name,
                  long stackSize, AccessControlContext acc,
                  boolean inheritThreadLocals) {
    // 可以看到如果线程名称 null， 会直接抛出异常
    if (name == null) {
        throw new NullPointerException("name cannot be null");
    }
    // 线程名称赋值
    this.name = name;
    // currentThread() 获取当前线程正在被那个线程调用
    Thread parent = currentThread();
    // 获取系统安全管理，没有返回 null 作用：防止启动Java 程序中，有恶意代码(删除系统文件、重启系统)，这个时候就需要启动 Java 安全
    // 管理器， 怎么使用可以看下这个： https://cloud.tencent.com/developer/article/1793295
    SecurityManager security = System.getSecurityManager();
    // 如果线程组没有显示传入 为 null
    if (g == null) {
        /* Determine if it's an applet or not */

        /* If there is a security manager, ask the security manager
           what to do. */
        // 如果开启了安全管理器，则当前线程组 g = 安全管理器的线程组
        if (security != null) {
            g = security.getThreadGroup();
        }

        /* If the security doesn't have a strong opinion of the matter
           use the parent thread group. */
        // 如果没有开启安全管器，则获取调用当前线程的线程组
        if (g == null) {
            g = parent.getThreadGroup();
        }
    }

    /* checkAccess regardless of whether or not threadgroup is
       explicitly passed in. */
    // 确定当前线程是否有权限修改线程组
    g.checkAccess();

    /*
     * Do we have the required permissions?
     */
     // 是否开启了安全管理器
    if (security != null) {
        if (isCCLOverridden(getClass())) {
            security.checkPermission(SUBCLASS_IMPLEMENTATION_PERMISSION);
        }
    }

    // 增加未启动线程的计数
    g.addUnstarted();
    // 线程组的赋值
    this.group = g;
    // 守护进程标示赋值默认false
    this.daemon = parent.isDaemon();
    // 线程优先级
    this.priority = parent.getPriority();
    if (security == null || isCCLOverridden(parent.getClass()))
        this.contextClassLoader = parent.getContextClassLoader();
    else
        this.contextClassLoader = parent.contextClassLoader;
    this.inheritedAccessControlContext =
            acc != null ? acc : AccessController.getContext();
    // 目标线程调用
    this.target = target;
    // 设置线程优先级
    setPriority(priority);
    if (inheritThreadLocals && parent.inheritableThreadLocals != null)
        this.inheritableThreadLocals =
            ThreadLocal.createInheritedMap(parent.inheritableThreadLocals);
    /* Stash the specified stack size in case the VM cares */
   // 线程栈大小
    this.stackSize = stackSize;

    /* Set thread ID */
    // 线程ID
    tid = nextThreadID();
}
```

到此一个线程的所有属性初始化完毕。

### 线程启动

线程启动是通过调用 start() 方法启动的，线程从 NEW 状态转换为 RUNNABLE，然后由 JVM 调用该线程的 run 方法去执行该线程的逻辑。直接调用
run() 方法就是执行该类的 run() 方法逻辑，和调用该类的普通方法没什么区别。

来看一下调用 start() 方法具体做了哪些操作：

```
/**
 * Causes this thread to begin execution; the Java Virtual Machine
 * calls the <code>run</code> method of this thread.
 * <p>
 * The result is that two threads are running concurrently: the
 * current thread (which returns from the call to the
 * <code>start</code> method) and the other thread (which executes its
 * <code>run</code> method).
 * <p>
 * It is never legal to start a thread more than once.
 * In particular, a thread may not be restarted once it has completed
 * execution.
 *
 * @exception  IllegalThreadStateException  if the thread was already
 *               started.
 * @see        #run()
 * @see        #stop()
 */
public synchronized void start() {
    /**
     * This method is not invoked for the main method thread or "system"
     * group threads created/set up by the VM. Any new functionality added
     * to this method in the future may have to also be added to the VM.
     *
     * A zero status value corresponds to state "NEW".
     */
     // 判断线程状态是否已经启动，如果已经启动则抛出线程状态异常
    if (threadStatus != 0)
        throw new IllegalThreadStateException();

    /* Notify the group that this thread is about to be started
     * so that it can be added to the group's list of threads
     * and the group's unstarted count can be decremented. */
    // 此时线程组中才将该线程放入
    group.add(this);

    boolean started = false;
    try {
        // 调用本地方法启动线程
        start0();
        started = true;
    } finally {
        try {
            if (!started) {
                group.threadStartFailed(this);
            }
        } catch (Throwable ignore) {
            /* do nothing. If start0 threw a Throwable then
              it will be passed up the call stack */
        }
    }
}
```

### 线程组添加线程

group.add(this); 看一下线程组是如何添加线程的，源码如下：

```
/**
 * Adds the specified thread to this thread group.
 *
 * <p> Note: This method is called from both library code
 * and the Virtual Machine. It is called from VM to add
 * certain system threads to the system thread group.
 *
 * @param  t
 *         the Thread to be added
 *
 * @throws  IllegalThreadStateException
 *          if the Thread group has been destroyed
 */
void add(Thread t) {
    synchronized (this) {
        // 前提是线程没销毁
        if (destroyed) {
            throw new IllegalThreadStateException();
        }
        // threads 数组什么时候初始化为大小为 4 的：JVM 在初始化的时候会向启动组中添加守护线程
        // 比较奇怪的是在 win 上可以看到 4 个， 在 Mac 上只能看到 3 个

       
        if (threads == null) {
            threads = new Thread[4];
        } else if (nthreads == threads.length) {
            threads = Arrays.copyOf(threads, nthreads * 2);
        }
        threads[nthreads] = t;

        // This is done last so it doesn't matter in case the
        // thread is killed
        // 因为启动线程数加 1 是最后完成的，即使线程被杀死也没关系
        nthreads++;

        // The thread is now a fully fledged member of the group, even
        // though it may, or may not, have been started yet. It will prevent
        // the group from being destroyed so the unstarted Threads count is
        // decremented.
        // 因为线程已经添加到线程组中，尽管线程状态不确定是否启动，但是该线程已经是线程中的正式成员，所以未启动线程减一
        nUnstartedThreads--;
    }
}
```
将线程添加到线程组中后，调用本地 start0() 方法启动线程。在初始化 Thread 的时候，首先会有一个静态初始化的过程：

```
/* Make sure registerNatives is the first thing <clinit> does. */
private static native void registerNatives();
static {
    registerNatives();
}
```

**这个本地方法主要的作用就是完成了该类中本地方法的注册。至于注册了哪些方法，为什么要注册，注册的作用**还没研究。 记个ToDo吧。
参考链接： https://blog.csdn.net/Saintyyu/article/details/90452826

完成本地方法注册，然后调用 start0() 启动线程。

## 小结

通过源码可以知道，实现 Runnable 接口创建线程和 继承 Thread 类创建线程的没什么本质区别，Thread 类同样实现了 Runnable 接口，只是 Thread 类
提供了更多对线程的可用方法和属性。

# 实例变量共享造成的非线程安全问题
自定义线程类中的实例变量针对其他线程可以分为可共享和不共享两类。这在多线程交互时是很重要的技术点。

## 不共享的数据

该线程内所拥有资源对于其他线程不可见。

### 测试用例
创建 ABC 三个线程，各自为 ThreadVariable 类中的变量赋值，然后启动，代码如下：

```java
public class ThreadVariable implements Runnable{

    private int count;

    public void setCount(int count) {
        this.count = count;
    }

    @Override
    public void run() {
        while (count > 0){
            count--;
            System.out.println("由" + Thread.currentThread().getName() + "计算， count=" + count);
        }
    }
}


public class ThreadTest {
    public static void main(String[] args) {
        // 设置 A 线程 count
        ThreadVariable varT1 = new ThreadVariable();
        varT1.setCount(10);
        Thread t1 = new Thread(varT1);
        t1.setName("A");
        t1.start();

        ThreadVariable varT2 = new ThreadVariable();
        varT2.setCount(10);
        Thread t2 = new Thread(varT2);
        t2.setName("B");
        t2.start();

        ThreadVariable varT3 = new ThreadVariable();
        varT3.setCount(10);
        Thread t3 = new Thread(varT3);
        t3.setName("C");
        t3.start();
    }
}
```

一共创建了三个线程，每个线程都拥有自己的 count 变量，自己减少自己的count变量，彼此互不共享，。

## 共享的数据

共享数据的情况是多个线程共同访问一个变量。比较典型的场景是多个线程共同处理一个人的票数，即多用户通过线上给某一个人投票，计数。

用上述例子，将 count 放到 while 循环之外，然后创建多个线程，执行。

测试代码如下：

```
System.out.println("=======================线程变量共享 start=====================");
ThreadVariableShare varT4 = new ThreadVariableShare();
varT4.setCount(10);
Thread t4 = new Thread(varT1);
t4.setName("varT4");
t4.start();

ThreadVariableShare varT5 = new ThreadVariableShare();
Thread t5 = new Thread(varT2);
t5.setName("varT5");
t5.start();

ThreadVariableShare varT6 = new ThreadVariableShare();
Thread t6 = new Thread(varT3);
t6.setName("varT6");
t6.start();
System.out.println("=======================线程变量共享 end=====================");
```
仔细观察打印结果会发现，count 会有相同的值被不同的线程打印出来，这样就产生了 "非线程安全" 问题，正常情况下，count 的输出值因该是递减的，
而不应该是重复的。

出现重复值是因为在某些 JVM 中，count-- 操作要分解成如下 3 步(而执行这 3 个步骤的过程中会被其他线程打断)：

1. 取得原有 count 值；
2. 计算 count - 1；
3. 对 count 赋值；

这三步任意一步都可能被其他线程打断，从而造成取得 count 值的结果不一致。

书中还介绍了一个比较典型的案例：Servlet 技术造成的非线程安全问题与解决方案：

非线程安全问题主要是指多个线程对同一个对象中的同一个实例变量进行操作时会出现值被更改、值不同步的情况，进而影响程序的执行流程。
代码如下：

模拟实现一个组件
```
/**
 * 模拟一个 servlet 登陆组件
 */
public class ThreadServletLogin {
    private static String usernameRef;
    private static String passwordRef;

    public static void doPost(String username, String password){
        usernameRef = username;
        if(username.equals("a")){
            try {
                Thread.sleep(5000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        passwordRef = password;
        System.out.println("username= " + usernameRef + " password= " + passwordRef);
    }
}
```

创建两个线程模拟登陆
```
public class ThreadServletLoginA  extends Thread{
    @Override
    public void run() {
        ThreadServletLogin.doPost("a", "LoginA");
    }
}

public class ThreadServletLoginB extends Thread{
    @Override
    public void run() {
        ThreadServletLogin.doPost("b", "Loginb");
    }
}
```

测试类
```
public class ThreadServletLoginTest {
    public static void main(String[] args) {
        ThreadServletLoginA aLogin = new ThreadServletLoginA();
        aLogin.start();
        ThreadServletLoginB bLogin = new ThreadServletLoginB();
        bLogin.start();
    }
}
```

输出结果就会出现以下几种情况：
```
a bb
a aa
------
b aa
b bb
```

ToDo: 后续章节再介绍如何解决这种 "非线程安全问题" 。下面来看一下 Thread 类提供的

# Thread 提供的方法

## currentThread() 方法

该方法可以返回代码段正在被那个线程调用。通过该方法可以验证一下使用 start 启动线程和直接调用 run 方法的不同.
测试类：
```
public class CurrentThreadMethod extends Thread{

    public CurrentThreadMethod(){
        System.out.println("构造方法的打印，当前线程执行名称：: " + Thread.currentThread().getName());
    }

    @Override
    public void run() {
        System.out.println("run 方法打印, 当前线程执行名称：" + Thread.currentThread().getName());
    }
}


public class ThreadMethod {
    public static void main(String[] args) {
        CurrentThreadMethod currentThreadMethod = new CurrentThreadMethod();
        Thread t = new Thread(currentThreadMethod);
        t.start();
        t.run();

    }
}

// 输出结果

构造方法的打印，当前线程执行名称：: main
run 方法打印, 当前线程执行名称：main
run 方法打印, 当前线程执行名称：Thread-1
```

1. 观察输出结果能看到 直接调用 run 方法是由 main 调用的，并没有启动一个线程，使用 start 调用则是启动了一个新的线程；
2. 直接调用 run 方法是立即执行的， t.start() 则是需要等待 CPU 调度，然后执行。

### this.getName() 和 currentThread.getName()

currentThread.getName()方法: 返回当前代码段正在被那个线程调用；

this.getName()方法：获取当前对象的名字，只是单纯的方法调用；

```
public class CurrentThreadMethod extends Thread{

    public CurrentThreadMethod(){
        System.out.println("构造方法的打印，当前线程执行名称：: " + Thread.currentThread().getName());
        System.out.println("构造方法的打印，当前类的名称：" + this.getName());
    }

    @Override
    public void run() {
        System.out.println("run 方法打印, 当前线程执行名称：" + Thread.currentThread().getName());
        System.out.println("run 方法打印，当前类的名称" + this.getName());
    }
}

public class ThreadMethod {
    public static void main(String[] args) {
        CurrentThreadMethod currentThreadMethod = new CurrentThreadMethod();
        Thread t = new Thread(currentThreadMethod);
        t.setName("执行线程A");
        t.start();
        t.run();

    }
}

// 输出结果
构造方法的打印，当前线程执行名称：: main
构造方法的打印，当前类的名称：Thread-0
run 方法打印, 当前线程执行名称：main
run 方法打印，当前类的名称Thread-0
run 方法打印, 当前线程执行名称：执行线程A
run 方法打印，当前类的名称Thread-0
```
this.getName() 代表的是 CurrentThreadMethod 对象的名称, 只是单纯的方法调用，没有重写这个方法，所以调用的是父类 Thread 方法，初始化 
CurrentThreadMethod 的 name 名称 Thread-0；

t.setName() 的 name 是 Thread 对象，并不会影响 CurrentThreadMethod 的 name 属性

## isAlive() 方法

isAlive() 方法的功能是判断当前的线程是否存活。
```
public class ThreadisAliveMethod extends Thread{
    @Override
    public void run() {
        System.out.println("run=" + Thread.currentThread().isAlive());
    }
}


ThreadisAliveMethod threadisAliveMethod = new ThreadisAliveMethod();
System.out.println("threadisAliveMethod 线程状态 start ：" + threadisAliveMethod.isAlive());
threadisAliveMethod.start();
System.out.println("threadisAliveMethod 线程状态 end：" + threadisAliveMethod.isAlive());

// 输出结果
threadisAliveMethod 线程状态 start ：false
threadisAliveMethod 线程状态 end：true
run=true
```

注意这里 end=true 是不确定的，因为在执行打印 end 的时候，线程可能未结束，因而 end=true。如果改将代码更改一下：
```
ThreadisAliveMethod threadisAliveMethod = new ThreadisAliveMethod();
System.out.println("threadisAliveMethod 线程状态 start ：" + threadisAliveMethod.isAlive());
threadisAliveMethod.start();
try {
    Thread.sleep(1000);
} catch (InterruptedException e) {
    //doNothing
}
System.out.println("threadisAliveMethod 线程状态 end：" + threadisAliveMethod.isAlive());

// 输出结果
threadisAliveMethod 线程状态 start ：false
run=true
threadisAliveMethod 线程状态 end：false
```

Thread.sleep(1000) 是让 main 线程停止 1 秒，过 1s 后 threadisAliveMethod 线程执行完成，此时该线程状态 end = true。

### this.isAlive() 和 currentThread.isAlive()

当将线程对象以构造参数的方式传递给 Thread 对象进行 start 启动时，运行的结果与前面是有差异的。示例如下：

```
public class ThreadisAliveMethod extends Thread{

    public ThreadisAliveMethod() {
        System.out.println("ThreadisAliveMethod-------------begin");
        System.out.println("Thread.currentThread.getName=" + Thread.currentThread().getName());
        System.out.println("currentThread.isAlive=" + Thread.currentThread().isAlive());
        System.out.println("this.getName()=" + this.getName());
        System.out.println("this.isAlive=" + this.isAlive());
        System.out.println("ThreadisAliveMethod-------------end");

    }

    @Override
    public void run() {
        System.out.println("run-------------begin");
        System.out.println("Thread.currentThread.getName=" + Thread.currentThread().getName());
        System.out.println("currentThread.isAlive=" + Thread.currentThread().isAlive());
        System.out.println("thi.getName()=" + this.getName());
        System.out.println("this.isAlive=" + this.isAlive());
        System.out.println("run-------------end");
    }
}

ThreadisAliveMethod aliveMethod = new ThreadisAliveMethod();
Thread t2 = new Thread(aliveMethod);
System.out.println("t2 线程状态 start ：" + t2.isAlive());
t2.setName("aliveThread");
t2.start();
System.out.println("t2 线程状态 end：" + t2.isAlive());


输出结果：
ThreadisAliveMethod-------------begin
Thread.currentThread.getName=main
currentThread.isAlive=true
thi.getName()=Thread-0
this.isAlive=false
ThreadisAliveMethod-------------end
t2 线程状态 start ：false
t2 线程状态 end：true
run-------------begin
Thread.currentThread.getName=aliveThread
currentThread.isAlive=true
thi.getName()=Thread-0
this.isAlive=false
run-------------end
```
当我们将线程对象以构造参数的形式传递给 Thread 对象进行 start 启动，使用 Thread.currentThread 和 this 代表的对象是不一样的。因为我们将线程
对象作为构造参数传递给 Thread 类，然后使用 Thread 方法 start 启动线程，然后执行的是传递的线程对象的 run 方法，所以 this.isAlive() 获取的是
没有被启动的线程对象信息，而使用Thread.currentThread() 获取的得则是调用这段代码的线程信息，即 Thread 信息。所以本次示例的结果才与前面的示例结果
有差异。

## sleep(long millis) 方法
sleep 方法的作用是在指定时间(毫秒)内让当前正在执行的线程休眠(暂停执行), 这个正在执行的线程是指 this.currentThread() 返回的线程。

```
public class ThreadSleepMethod extends Thread{
    @Override
    public void run() {
        System.out.println("run threadName = " + this.currentThread().getName() + "begin");
        try {
            this.sleep(2000);
            System.out.println("run threadName = "+ currentThread().getName() + "end");
        } catch (InterruptedException e) {
            // doNothing
        }
    }
}

// 直接调用 run方法
ThreadSleepMethod threadSleepMethod = new ThreadSleepMethod();
System.out.println("begin----------------" + System.currentTimeMillis());
threadSleepMethod.run();
System.out.println("end------------------" + System.currentTimeMillis());
```

当调用 sleep() 方法是所在类是 Thread 时，则执行代码 this.sleep() 和 Thread.sleep() 效果是一样的，结果如下：
```
// this.sleep() 结果
begin----------------1647745747085
run threadName = mainbegin
run threadName = mainend
end------------------1647745749090花费时间为=2s
// Thread.sleep()
begin----------------1647745810897
run threadName = mainbegin
run threadName = mainend
end------------------1647745812901花费时间为=2s
```
启动线程测试：
```
long start2 = System.currentTimeMillis();
ThreadSleepMethod sleepMethod = new ThreadSleepMethod();
System.out.println("begin----------------" + start2);
sleepMethod.start();
System.out.println("end------------------" + System.currentTimeMillis() + "花费时间为=" +(System.currentTimeMillis() - start2)/1000 + "s");

// 输出结果：
begin----------------1647745985861
end------------------1647745985862花费时间为=0s
run threadName = Thread-0begin
run threadName = Thread-0end
```
由于 main 线程与 sleepMethod 异步，sleepMethod 暂停 2s 执行，所以首先输出 main 线程打印的信息，2s 后输出 sleepMethod 信息

### sleep(long millis, int nanos) 方法

该方法的作用是在指定的毫秒数加指定的纳秒数内让当前正在执行的线程休眠，此操作系统受到系统计时器和调度程序的精准度和准确性的影响。

```
// sleep(long millis, int nanos)
long start3 = System.currentTimeMillis();
System.out.println("begin----------------" + start3);
try {
    Thread.sleep(2000, 999999);
} catch (InterruptedException e) {
    e.printStackTrace();
}
System.out.println("end------------------" + System.currentTimeMillis() + "花费时间为=" +(System.currentTimeMillis() - start3) + "ms");

// 输出结果：
begin----------------1647748698686
end------------------1647748700690花费时间为=2004ms
```
可以看到 ns 级线程的休眠时间并不是那么准确了。

## getStackTrace() 方法

该方法的作用是返回一个表示该该线程堆栈跟踪元素数组。如果线程尚未启动或者已经终止，则该方法将返回一个 0 长度数组。否则数组中第一个元素代表
堆栈顶，它是该数组中最新的方法调用；最后一个元素代表堆栈底，是该数组中最开始的方法调用。测试代码如下：

```
public class GetStackTraceThreadMethod extends Thread{

    private void a(){
        b();
    }

    private void b(){
        c();
    }

    private void c(){
        d();
    }

    private void d(){
        e();
    }

    private void e(){
        StackTraceElement[]  elementArray = Thread.currentThread().getStackTrace();
        if(elementArray != null){
            for (StackTraceElement element : elementArray) {
                System.out.println("className= " + element.getClassName() + "\nmethodName= " + element.getMethodName() +
                        "\nfileName= " + element.getFileName() + "\nlineNumber= " + element.getLineNumber());
            }
        }else{
            System.out.println("线程没有启动");
        }

        StackTraceElement[]  elementArray2 = this.getStackTrace();
        System.out.println("当前线程类 GetStackTraceThreadMethod 大小为= " + elementArray2.length);
        if(elementArray2 != null){
            for (StackTraceElement element : elementArray2) {
                System.out.println("className= " + element.getClassName() + "\nmethodName= " + element.getMethodName() +
                        "\nfileName= " + element.getFileName() + "\nlineNumber= " + element.getLineNumber());
            }
        }else{
            System.out.println("线程没有启动");
        }
    }

    @Override
    public void run() {
        System.out.println("run---------------------------start");
        a();
        System.out.println("run---------------------------end");
    }
}

public class GetStackTraceThreadMethodTest {
    
    public static void main(String[] args) {
//        // 直接启动线程
//        GetStackTraceThreadMethod stackTraceThreadMethod = new GetStackTraceThreadMethod();
//        stackTraceThreadMethod.setName("getStackTrace");
//        stackTraceThreadMethod.start();

        // 作为构造参数传入
        GetStackTraceThreadMethod stackTraceThreadMethod1 = new GetStackTraceThreadMethod();
        Thread t= new Thread(stackTraceThreadMethod1);
        t.setName("getStackTrace2");
        t.start();
    }
}

输出结果：
run---------------------------start
className= java.lang.Thread
methodName= getStackTrace
fileName= Thread.java
lineNumber= 1559
className= com.anzhi.threadmethod.getstacktrace.GetStackTraceThreadMethod
methodName= e
fileName= GetStackTraceThreadMethod.java
lineNumber= 23
className= com.anzhi.threadmethod.getstacktrace.GetStackTraceThreadMethod
methodName= d
fileName= GetStackTraceThreadMethod.java
lineNumber= 19
className= com.anzhi.threadmethod.getstacktrace.GetStackTraceThreadMethod
methodName= c
fileName= GetStackTraceThreadMethod.java
lineNumber= 15
className= com.anzhi.threadmethod.getstacktrace.GetStackTraceThreadMethod
methodName= b
fileName= GetStackTraceThreadMethod.java
lineNumber= 11
className= com.anzhi.threadmethod.getstacktrace.GetStackTraceThreadMethod
methodName= a
fileName= GetStackTraceThreadMethod.java
lineNumber= 7
className= com.anzhi.threadmethod.getstacktrace.GetStackTraceThreadMethod
methodName= run
fileName= GetStackTraceThreadMethod.java
lineNumber= 48
className= java.lang.Thread
methodName= run
fileName= Thread.java
lineNumber= 748
当前线程类 GetStackTraceThreadMethod 大小为= 0
run---------------------------end
```













