# Java å¤šçº¿ç¨‹
åœ¨çº¿ç¨‹è¿™ä¸ªæ¦‚å¿µæå‡ºä¹‹å‰ï¼Œåœ¨æ“ä½œç³»ç»Ÿä¸­åªæœ‰è¿›ç¨‹çš„æ¦‚å¿µã€‚è¿›ç¨‹æ˜¯æ“ä½œç³»ç»Ÿç»“æ„çš„åŸºç¡€ï¼›æ˜¯ä¸€æ¬¡ç¨‹åºçš„æ‰§è¡Œã€‚æ˜¯ç³»ç»Ÿè¿›è¡Œèµ„æºåˆ†é…å’Œ
è°ƒåº¦çš„ä¸€ä¸ªç‹¬ç«‹å•ä½ã€‚

ç¨‹åºæ˜¯æŒ‡åºåˆ—æŒ‡ä»¤ï¼Œè¿™äº›æŒ‡ä»¤å¯ä»¥è®© CPU æŒ‰ç…§äººç±»æŒ‡ä»¤å®Œæˆç›¸åº”çš„ä»»åŠ¡ã€‚åœ¨æ“ä½œç³»ç»Ÿä¸­å¯åŠ¨ä¸€ä¸ª JVM è™šæ‹Ÿæœºå°±ç›¸å½“äºåˆ›å»ºäº†ä¸€ä¸ªè¿›ç¨‹ã€‚

é‚£ä»€ä¹ˆæ˜¯çº¿ç¨‹å‘¢ï¼Ÿçº¿ç¨‹æ˜¯è¿›ç¨‹ä¸­ç‹¬ç«‹è¿è¡Œçš„å­ä»»åŠ¡ï¼Œå¯ä»¥å…±äº«è¿›ç¨‹ä¸­ç›¸åŒçš„å†…å­˜æˆ–æ–‡ä»¶èµ„æºã€‚

# Java çº¿ç¨‹çš„ä½¿ç”¨

## ç»§æ‰¿ Thread ç±»

Java JDK ä¸­åŒ…å«äº†å¯¹å¤šçº¿ç¨‹æŠ€æœ¯çš„æ”¯æŒã€‚å®ç°å¤šçº¿ç¨‹ç¼–ç¨‹ä¸»è¦æœ‰ä¸¤ç§æ–¹å¼ï¼š

1. ç»§æ‰¿ Thread ç±»ï¼›

2. å®ç° Runnable æ¥å£

### ç»§æ‰¿ Thread ç±»

```java
public class CreateThreadByExtendsThread extends Thread{
    @Override
    public void run() {
        super.run();
        System.out.println("Create Thread by Extends Thread Begin to Run!");
    }
}
```


```java
public class ThreadTest {
    public static void main(String[] args) {
        CreateThreadByExtendsThread t = new CreateThreadByExtendsThread();
        t.setName("CreateThreadByExtendsThread"); // æŒ‡å®šçº¿ç¨‹æ‰§è¡Œåç§°
        t.start();  // è€—æ—¶è¾ƒé•¿
        System.out.println("å½“å‰çº¿ç¨‹" + Thread.currentThread().getName() + "æ‰§è¡Œç»“æŸ\n" + "å½“å‰çº¿ç¨‹" + t.getName() + "æ‰§è¡Œç»“æŸ"); //ä¸»çº¿ç¨‹è€—æ—¶è¾ƒçŸ­
    }
}
```

å¤šæ¬¡æ‰§è¡Œçš„ç»“æœï¼Œä»”ç»†è§‚å¯Ÿå°±ä¼šå‘ç°ï¼Œè¾“å‡ºç»“æœå¹¶ä¸æ˜¯éšç€è°ƒç”¨é¡ºåºè€Œè¾“å‡ºçš„ã€‚è€Œç¨‹åºä¸­æ‰§è¡Œ startæ–¹æ³•æ¯”è¾ƒè€—æ—¶æ˜¯å› ä¸ºè¯¥æ–¹æ³•æ‰§è¡Œäº†å¤šä¸ªæ­¥éª¤ã€‚æ­¥éª¤å¦‚ä¸‹ï¼š

1. é€šè¿‡ JVM å‘Šè¯‰æ“ä½œç³»ç»Ÿåˆ›å»º Threadï¼›

2. é€šè¿‡æ“ä½œç³»ç»Ÿå¼€è¾Ÿå†…å­˜å¹¶ä½¿ç”¨æ“ä½œç³»ç»Ÿ SDK ä¸­çš„ createThread() å‡½æ•°åˆ›å»º Thread çº¿ç¨‹å¯¹è±¡ï¼›

3. æ“ä½œç³»ç»Ÿå¯¹ Thread å¯¹è±¡è¿›è¡Œè°ƒåº¦ï¼Œä»¥ç¡®å®šæ‰§è¡Œæ—¶æœºï¼›

4. Thread åœ¨æ“ä½œç³»ç»Ÿä¸­è¢«æ‰§è¡ŒæˆåŠŸ

ä»¥ä¸Š4ä¸ªæ­¥éª¤æ‰§è¡Œå®Œæˆæ¶ˆè€—çš„æ—¶é—´ä¸€å®šå¤§äº main æ–¹æ³•ä¸­çš„è¾“å‡ºæ—¶é—´ã€‚è€Œä¸” main æ–¹æ³•æ‰§è¡Œ start() æ–¹æ³•æ—¶ä¸éœ€è¦ç­‰4ä¸ªæ­¥éª¤éƒ½æ‰§è¡Œå®Œæ¯•ï¼Œè€Œæ˜¯ç»§ç»­æ‰§è¡Œ start()
æ–¹æ³•åé¢çš„ä»£ç ï¼Œå¦‚æœåœ¨ä¸»çº¿ç¨‹ä¸­ç›´æ¥è°ƒç”¨ run æ–¹æ³•ï¼Œè¾“å‡ºé¡ºåºå°±æ˜¯æŒ‰ç…§ä»£ç é¡ºåºè¾“å‡ºï¼Œæ­¤æ—¶çš„ run æ–¹æ³•æ˜¯ç”±ä¸»çº¿ç¨‹è°ƒç”¨çš„ï¼Œæ‰€ä»¥æ‰ä¼šæŒ‰ç…§ä»£ç é¡ºåºæ‰§è¡Œã€‚

å¤šçº¿ç¨‹éšæœºè¾“å‡ºçš„åŸå› æ˜¯ CPU å°†æ—¶é—´ç‰‡åˆ†ç»™ä¸åŒçš„çº¿ç¨‹ï¼Œçº¿ç¨‹è·å¾—æ—¶é—´ç‰‡åå°±å¼€å§‹æ‰§è¡Œä»»åŠ¡ï¼Œçº¿ç¨‹è·å¾—æ—¶é—´ç‰‡æ˜¯éšæœºçš„ï¼Œæ‰§è¡Œè¾“å‡ºçš„é¡ºåºè‡ªç„¶ä¹Ÿæ˜¯ä¹±åºçš„ã€‚

## å®ç° Runnable æ¥å£

å¦‚æœæƒ³åˆ›å»ºçš„çº¿ç¨‹ç±»å·²ç»æœ‰äº†ä¸€ä¸ªçˆ¶ç±»äº†ï¼Œé‚£ä¹ˆå°±ä¸èƒ½å†ç»§æ‰¿ Thread ç±»ï¼Œæ­¤æ—¶å°±éœ€è¦å®ç° Runnable æ¥å£æ¥è§£å†³è¿™æ ·çš„é—®é¢˜ã€‚

```java
public class CreateThreadByRunnable implements Runnable{

    @Override
    public void run() {
        System.out.println("Create Thread by implements Runnable Begin to Run!");
    }
}
```

```
public class ThreadTest {
    public static void main(String[] args) {
        CreateThreadByRunnable runnable = new CreateThreadByRunnable();
        Thread t2 = new Thread(runnable);
        t2.setName("CreateThreadByRunnable");
        t2.start();  // è€—æ—¶è¾ƒé•¿
        System.out.println("å½“å‰çº¿ç¨‹" + Thread.currentThread().getName() + "æ‰§è¡Œç»“æŸ\n" + "å½“å‰çº¿ç¨‹" + t2.getName() + "æ‰§è¡Œç»“æŸ"); //ä¸»çº¿ç¨‹è€—æ—¶è¾ƒçŸ­
    }
}
```

### ä½¿ç”¨ Runnable æ¥å£å®ç°å¤šçº¿ç¨‹çš„ä¼˜ç‚¹

ä½¿ç”¨ç»§æ‰¿ Thread ç±»çš„æ–¹å¼å®ç°å¤šçº¿ç¨‹åœ¨ç¨‹åºè®¾è®¡ä¸Šæ˜¯æœ‰å±€é™æ€§çš„ï¼Œè¿™æ˜¯ç”± Java æœ¬èº«ä¸æ”¯æŒå¤šç»§æ‰¿å¯¼è‡´çš„ã€‚ä¸ºäº†è§£å†³è¿™æ ·çš„å±€é™æ€§ï¼Œå› æ­¤é‡‡ç”¨å®ç° Runnable
æ¥å£æ¥å®ç°å¤šçº¿ç¨‹çš„å¼€å‘

åœ¨ Thread.java ç±»ä¸­ä¹Ÿå®ç°äº† Runnable æ¥å£ã€‚

```java
public
class Thread implements Runnable {
    /* Make sure registerNatives is the first thing <clinit> does. */
    private static native void registerNatives();

    static {
        registerNatives();
    }
    //...çœç•¥
}
```

æµ‹è¯•ä»£ç å¦‚ä¸‹ï¼š

```
public class ThreadTest {
    public static void main(String[] args) {
        CreateThreadByExtendsThread t = new CreateThreadByExtendsThread();
        t.setName("CreateThreadByExtendsThread"); // æŒ‡å®šçº¿ç¨‹æ‰§è¡Œåç§°
        t.start();  // è€—æ—¶è¾ƒé•¿
        System.out.println("å½“å‰çº¿ç¨‹" + Thread.currentThread().getName() + "æ‰§è¡Œç»“æŸ\n" + "å½“å‰çº¿ç¨‹" + t.getName() + "æ‰§è¡Œç»“æŸ"); //ä¸»çº¿ç¨‹è€—æ—¶è¾ƒçŸ­
        
        // CreateThreadByExtendsThread æ˜¯ Thread å­ç±»ï¼Œ
        // Thread æ˜¯ Runnable å­ç±»ï¼Œæ‰€ä»¥ CreateThreadByExtendsThread ç›¸å½“äº Thread çš„å®ç°ç±»
        // æ‰€ä»¥æ„é€ å‡½æ•°å¯ä»¥ä¼ å…¥ä¸€ä¸ª Thread ç±»ï¼Œè¿™æ ·å®Œå…¨å¯ä»¥å°† Thread ç±»å¯¹è±¡ä¸­çš„ run æ–¹æ³•äº¤ç”±å…¶ä»–çº¿ç¨‹è°ƒç”¨
        
        Thread t3 = new Thread(t);
        t3.setName("æµ‹è¯•Threadå¯ä»¥ä¼ å…¥Runnableæ¥å£");
        t3.start();
    }
}
```

# å®ç° Runnable æ¥å£ä¸ç»§æ‰¿ Thread ç±»çš„å†…éƒ¨æµç¨‹

## Threadæ‰§è¡Œæµç¨‹ï¼š

![Threadæ‰§è¡Œæµç¨‹](../å›¾ç‰‡/1.extendsThreadExecuteProccess.png)

åˆ›å»ºçº¿ç¨‹çš„æ—¶å€™å¯ä»¥ä¸ºçº¿ç¨‹æŒ‡å®šåå­—ï¼Œå¦‚æœæ²¡æœ‰æŒ‡å®šï¼Œçº¿ç¨‹åœ¨åˆ›å»ºçš„æ—¶å€™ä¼šè‡ªåŠ¨ä¸ºå®ƒç”Ÿæˆåå­—ã€‚è¿™ä¸ªæ“ä½œåœ¨ Thread çš„æ— å‚æ„é€ ä¸­ã€‚åœ¨æ— å‚æ„é€ å‡½æ•°ä¸­åˆ›å»º
è¿˜è°ƒç”¨äº† init æ–¹æ³•ï¼Œå®Œæˆå¯¹çº¿ç¨‹å±æ€§çš„åˆå§‹åŒ–ã€‚æºç å¦‚ä¸‹ï¼š

```
/**
 * Allocates a new {@code Thread} object. This constructor has the same
 * effect as {@linkplain #Thread(ThreadGroup,Runnable,String) Thread}
 * {@code (null, null, gname)}, where {@code gname} is a newly generated
 * name. Automatically generated names are of the form
 * {@code "Thread-"+}<i>n</i>, where <i>n</i> is an integer.
 */
public Thread() {
    init(null, null, "Thread-" + nextThreadNum(), 0);
}
```

### Thread å±æ€§

init æ–¹æ³•å®Œæˆå¯¹çº¿ç¨‹å±æ€§çš„åˆå§‹åŒ–ï¼Œäº†è§£ä¸€ä¸‹ Thread ç±»åŒ…å«äº†å“ªäº›å±æ€§ï¼š

```
private volatile String name; // çº¿ç¨‹åç§°
private int            priority; // çº¿ç¨‹ä¼˜å…ˆçº§ (ToDo 0: æœ‰å¤šå°‘çº§)
private boolean     single_step; // çº¿ç¨‹æ˜¯å¦å•æ­¥æ‰§è¡Œ é»˜è®¤ false
private boolean     daemon = false; // çº¿ç¨‹æ˜¯å¦ä¸ºå®ˆæŠ¤çº¿ç¨‹(ä»€ä¹ˆæ˜¯å®ˆæŠ¤çº¿ç¨‹ ToDo: 1)
private boolean     stillborn = false; // è™šæ‹ŸæœºçŠ¶æ€ (ToDo 2: æœ‰å“ªäº›ï¼Œæœ‰ä»€ä¹ˆä½œç”¨)

private Runnable target; // æœ€ç»ˆçº¿ç¨‹çš„é€»è¾‘æ‰§è¡Œæ˜¯é€šè¿‡ target è°ƒç”¨æ‰§è¡Œ
private ThreadGroup group; // çº¿ç¨‹ç»„(çº¿ç¨‹ç»„çš„ä½œç”¨ ToDo:3)
private ClassLoader contextClassLoader; // æ­¤çº¿ç¨‹çš„ ClassLoader(ç±»åŠ è½½å™¨)

private AccessControlContext inheritedAccessControlContext; // å½“å‰çº¿ç¨‹ç»§æ‰¿çš„æƒé™ï¼šæ§åˆ¶ä¸Šä¸‹æ–‡ã€ä»¥åŠå®‰å…¨æœºåˆ¶ç›¸å…³(æœªæ¥å¯èƒ½è¢«åºŸå¼ƒ)
private static int threadInitNumber; // è‡ªåŠ¨ç¼–å·åŒ¿åçº¿ç¨‹ å³æ²¡æœ‰ä¸»åŠ¨å‘½åçš„çº¿ç¨‹
ThreadLocal.ThreadLocalMap threadLocals = null;; // æ­¤çº¿ç¨‹çš„æœ¬åœ°å˜é‡å€¼.æ­¤mapç”±ThreadLocalç±»è¿›è¡Œç»´æŠ¤,å› ä¸ºè¿™ä¸ªç±»åœ¨ThreadLocalä¸­æ˜¯åŒ…çº§ç§æœ‰çš„, ThreadLocalMap æ˜¯ä¸€ä¸ªç”¨äºç»´æŠ¤çº¿ç¨‹æœ¬åœ°å˜é‡çš„ hashMao
ThreadLocal.ThreadLocalMap inheritableThreadLocals = null; // æ­¤çº¿ç¨‹ç»§æ‰¿æ‹¥æœ‰çš„æœ¬åœ°å˜é‡å€¼ï¼Œå³ A çº¿ç¨‹ç»§æ‰¿ Bçº¿ç¨‹ç§°ï¼Œ é‚£ä¹ˆ B çº¿ç¨‹ä¸­ threadLocals ç»´æŠ¤çš„å˜é‡åœ¨å­˜æ”¾åˆ°è¿™ inheritableThreadLocals ä¸­


private long stackSize;  //æ­¤çº¿ç¨‹è¯·æ±‚çš„å †æ ˆå¤§å°ï¼Œå¦‚æœåˆ›å»ºè€…æœªæŒ‡å®šå †æ ˆå¤§å°ï¼Œåˆ™ä¸º 0ã€‚æœ€ç»ˆç”±è™šæ‹ŸæŒ‡å®š(ToDo 4ï¼šäººä¸ºæŒ‡å®šä¼šä¸ä¼šç”Ÿæ•ˆ)ï¼›ä¸€äº›è™šæ‹Ÿæœºä¼šå¿½ç•¥å®ƒã€‚
private long nativeParkEventPointer; //åœ¨æœ¬æœºçº¿ç¨‹ç»ˆæ­¢åæŒç»­å­˜åœ¨çš„ JVM ç§æœ‰çŠ¶æ€ (ä¸çŸ¥é“æœ‰ä»€ä¹ˆä½œç”¨ ToDo 5ï¼š)
private long tid; çº¿ç¨‹ ID
private static long threadSeqNumber; // ç”¨äºç”Ÿæˆçº¿ç¨‹ ID
private volatile int threadStatus = 0; // çº¿ç¨‹æœ‰å“ªäº›çŠ¶æ€ 0: è¡¨ç¤ºæœªå¯åŠ¨ ToDo: 6
volatile Object parkBlocker; // æä¾›ç»™å½“å‰è°ƒç”¨ java.util.concurrent.locks.LockSupport.park çš„å‚æ•°ã€‚ç”±ï¼ˆç§æœ‰ï¼‰java.util.concurrent.locks.LockSupport.setBlocker è®¾ç½®ä½¿ç”¨ï¼Œ ç”±java.util.concurrent.locks.LockSupport.getBlocker è®¿é—®
private volatile Interruptible blocker; // å½“å‰çº¿ç¨‹åœ¨å¯ä¸­æ–­çš„ I/O æ“ä½œä¸­å¤„äºé˜»å¡çŠ¶æ€æ—¶ï¼Œåœ¨è®¾ç½®äº†å¯¹è±¡çš„ interrupt çŠ¶æ€åï¼Œå¿…é¡»è°ƒç”¨è¿™ä¸ªå¯¹è±¡çš„ interrupt æ–¹æ³•(ToDo 7: åé¢äº†è§£ä¸€ä¸‹)
public final static int MIN_PRIORITY = 1; // çº¿ç¨‹å…·å¤‡çš„æœ€ä½ä¼˜å…ˆçº§
public final static int NORM_PRIORITY = 5; // åˆ†é…ç»™çº¿ç¨‹é»˜è®¤çš„ä¼˜å…ˆçº§ï¼Œè¿™é‡Œçš„ä¼˜å…ˆçº§æ˜¯ä¸€ä¸ªå¤©èŠ±æ¿ï¼Œè€Œä¸æ˜¯ä¸€ä¸ªè®°å½•å°º
public final static int MAX_PRIORITY = 10; // çº¿ç¨‹æ‹¥æœ‰çš„æœ€å¤§ä¼˜å…ˆçº§ 10 delToDo 0
```

Thread çš„æ‰€æœ‰å±æ€§ä½œç”¨å’Œä½¿ç”¨åœºæ™¯ï¼Œä»¥åŠå˜é‡å‰é¢çš„ä¿®é¥°ç¬¦äº†è§£ä¸‹ã€‚åé¢å†æ·±å…¥ç ”ç©¶å§ã€‚ğŸ˜†

### init åˆå§‹åŒ–

```
public Thread() {
    init(null, null, "Thread-" + nextThreadNum(), 0);
}
```

nextThreadNum() å‡½æ•°æºç : ç”Ÿæˆå½“å‰çº¿ç¨‹ ID
```
private static synchronized int nextThreadNum() {
    return threadInitNumber++;
}
```
åœ¨ init æ–¹æ³•è°ƒç”¨äº† é‡è½½å®ç°çš„ initæ–¹æ³•ï¼Œæºç å¦‚ä¸‹ï¼š
```text
/**
 * Initializes a Thread with the current AccessControlContext.
 * @see #init(ThreadGroup,Runnable,String,long,AccessControlContext,boolean)
 */
private void init(ThreadGroup g, Runnable target, String name,
                  long stackSize) {
    init(g, target, name, stackSize, null, true);
}
```

#### çº¿ç¨‹åˆå§‹åŒ–æ ¸å¿ƒ

```
/**
 * Initializes a Thread.
 *
 * @param g the Thread group
 * @param target the object whose run() method gets called
 * @param name the name of the new Thread
 * @param stackSize the desired stack size for the new thread, or
 *        zero to indicate that this parameter is to be ignored.
 * @param acc the AccessControlContext to inherit, or
 *            AccessController.getContext() if null
 * @param inheritThreadLocals if {@code true}, inherit initial values for
 *            inheritable thread-locals from the constructing thread
 */
private void init(ThreadGroup g, Runnable target, String name,
                  long stackSize, AccessControlContext acc,
                  boolean inheritThreadLocals) {
    // å¯ä»¥çœ‹åˆ°å¦‚æœçº¿ç¨‹åç§° nullï¼Œ ä¼šç›´æ¥æŠ›å‡ºå¼‚å¸¸
    if (name == null) {
        throw new NullPointerException("name cannot be null");
    }
    // çº¿ç¨‹åç§°èµ‹å€¼
    this.name = name;
    // currentThread() è·å–å½“å‰çº¿ç¨‹æ­£åœ¨è¢«é‚£ä¸ªçº¿ç¨‹è°ƒç”¨
    Thread parent = currentThread();
    // è·å–ç³»ç»Ÿå®‰å…¨ç®¡ç†ï¼Œæ²¡æœ‰è¿”å› null ä½œç”¨ï¼šé˜²æ­¢å¯åŠ¨Java ç¨‹åºä¸­ï¼Œæœ‰æ¶æ„ä»£ç (åˆ é™¤ç³»ç»Ÿæ–‡ä»¶ã€é‡å¯ç³»ç»Ÿ)ï¼Œè¿™ä¸ªæ—¶å€™å°±éœ€è¦å¯åŠ¨ Java å®‰å…¨
    // ç®¡ç†å™¨ï¼Œ æ€ä¹ˆä½¿ç”¨å¯ä»¥çœ‹ä¸‹è¿™ä¸ªï¼š https://cloud.tencent.com/developer/article/1793295
    SecurityManager security = System.getSecurityManager();
    // å¦‚æœçº¿ç¨‹ç»„æ²¡æœ‰æ˜¾ç¤ºä¼ å…¥ ä¸º null
    if (g == null) {
        /* Determine if it's an applet or not */

        /* If there is a security manager, ask the security manager
           what to do. */
        // å¦‚æœå¼€å¯äº†å®‰å…¨ç®¡ç†å™¨ï¼Œåˆ™å½“å‰çº¿ç¨‹ç»„ g = å®‰å…¨ç®¡ç†å™¨çš„çº¿ç¨‹ç»„
        if (security != null) {
            g = security.getThreadGroup();
        }

        /* If the security doesn't have a strong opinion of the matter
           use the parent thread group. */
        // å¦‚æœæ²¡æœ‰å¼€å¯å®‰å…¨ç®¡å™¨ï¼Œåˆ™è·å–è°ƒç”¨å½“å‰çº¿ç¨‹çš„çº¿ç¨‹ç»„
        if (g == null) {
            g = parent.getThreadGroup();
        }
    }

    /* checkAccess regardless of whether or not threadgroup is
       explicitly passed in. */
    // ç¡®å®šå½“å‰çº¿ç¨‹æ˜¯å¦æœ‰æƒé™ä¿®æ”¹çº¿ç¨‹ç»„
    g.checkAccess();

    /*
     * Do we have the required permissions?
     */
     // æ˜¯å¦å¼€å¯äº†å®‰å…¨ç®¡ç†å™¨
    if (security != null) {
        if (isCCLOverridden(getClass())) {
            security.checkPermission(SUBCLASS_IMPLEMENTATION_PERMISSION);
        }
    }

    // å¢åŠ æœªå¯åŠ¨çº¿ç¨‹çš„è®¡æ•°
    g.addUnstarted();
    // çº¿ç¨‹ç»„çš„èµ‹å€¼
    this.group = g;
    // å®ˆæŠ¤è¿›ç¨‹æ ‡ç¤ºèµ‹å€¼é»˜è®¤false
    this.daemon = parent.isDaemon();
    // çº¿ç¨‹ä¼˜å…ˆçº§
    this.priority = parent.getPriority();
    if (security == null || isCCLOverridden(parent.getClass()))
        this.contextClassLoader = parent.getContextClassLoader();
    else
        this.contextClassLoader = parent.contextClassLoader;
    this.inheritedAccessControlContext =
            acc != null ? acc : AccessController.getContext();
    // ç›®æ ‡çº¿ç¨‹è°ƒç”¨
    this.target = target;
    // è®¾ç½®çº¿ç¨‹ä¼˜å…ˆçº§
    setPriority(priority);
    if (inheritThreadLocals && parent.inheritableThreadLocals != null)
        this.inheritableThreadLocals =
            ThreadLocal.createInheritedMap(parent.inheritableThreadLocals);
    /* Stash the specified stack size in case the VM cares */
   // çº¿ç¨‹æ ˆå¤§å°
    this.stackSize = stackSize;

    /* Set thread ID */
    // çº¿ç¨‹ID
    tid = nextThreadID();
}
```

åˆ°æ­¤ä¸€ä¸ªçº¿ç¨‹çš„æ‰€æœ‰å±æ€§åˆå§‹åŒ–å®Œæ¯•ã€‚

### çº¿ç¨‹å¯åŠ¨

çº¿ç¨‹å¯åŠ¨æ˜¯é€šè¿‡è°ƒç”¨ start() æ–¹æ³•å¯åŠ¨çš„ï¼Œçº¿ç¨‹ä» NEW çŠ¶æ€è½¬æ¢ä¸º RUNNABLEï¼Œç„¶åç”± JVM è°ƒç”¨è¯¥çº¿ç¨‹çš„ run æ–¹æ³•å»æ‰§è¡Œè¯¥çº¿ç¨‹çš„é€»è¾‘ã€‚ç›´æ¥è°ƒç”¨
run() æ–¹æ³•å°±æ˜¯æ‰§è¡Œè¯¥ç±»çš„ run() æ–¹æ³•é€»è¾‘ï¼Œå’Œè°ƒç”¨è¯¥ç±»çš„æ™®é€šæ–¹æ³•æ²¡ä»€ä¹ˆåŒºåˆ«ã€‚

æ¥çœ‹ä¸€ä¸‹è°ƒç”¨ start() æ–¹æ³•å…·ä½“åšäº†å“ªäº›æ“ä½œï¼š

```
/**
 * Causes this thread to begin execution; the Java Virtual Machine
 * calls the <code>run</code> method of this thread.
 * <p>
 * The result is that two threads are running concurrently: the
 * current thread (which returns from the call to the
 * <code>start</code> method) and the other thread (which executes its
 * <code>run</code> method).
 * <p>
 * It is never legal to start a thread more than once.
 * In particular, a thread may not be restarted once it has completed
 * execution.
 *
 * @exception  IllegalThreadStateException  if the thread was already
 *               started.
 * @see        #run()
 * @see        #stop()
 */
public synchronized void start() {
    /**
     * This method is not invoked for the main method thread or "system"
     * group threads created/set up by the VM. Any new functionality added
     * to this method in the future may have to also be added to the VM.
     *
     * A zero status value corresponds to state "NEW".
     */
     // åˆ¤æ–­çº¿ç¨‹çŠ¶æ€æ˜¯å¦å·²ç»å¯åŠ¨ï¼Œå¦‚æœå·²ç»å¯åŠ¨åˆ™æŠ›å‡ºçº¿ç¨‹çŠ¶æ€å¼‚å¸¸
    if (threadStatus != 0)
        throw new IllegalThreadStateException();

    /* Notify the group that this thread is about to be started
     * so that it can be added to the group's list of threads
     * and the group's unstarted count can be decremented. */
    // æ­¤æ—¶çº¿ç¨‹ç»„ä¸­æ‰å°†è¯¥çº¿ç¨‹æ”¾å…¥
    group.add(this);

    boolean started = false;
    try {
        // è°ƒç”¨æœ¬åœ°æ–¹æ³•å¯åŠ¨çº¿ç¨‹
        start0();
        started = true;
    } finally {
        try {
            if (!started) {
                group.threadStartFailed(this);
            }
        } catch (Throwable ignore) {
            /* do nothing. If start0 threw a Throwable then
              it will be passed up the call stack */
        }
    }
}
```

### çº¿ç¨‹ç»„æ·»åŠ çº¿ç¨‹

group.add(this); çœ‹ä¸€ä¸‹çº¿ç¨‹ç»„æ˜¯å¦‚ä½•æ·»åŠ çº¿ç¨‹çš„ï¼Œæºç å¦‚ä¸‹ï¼š

```
/**
 * Adds the specified thread to this thread group.
 *
 * <p> Note: This method is called from both library code
 * and the Virtual Machine. It is called from VM to add
 * certain system threads to the system thread group.
 *
 * @param  t
 *         the Thread to be added
 *
 * @throws  IllegalThreadStateException
 *          if the Thread group has been destroyed
 */
void add(Thread t) {
    synchronized (this) {
        // å‰ææ˜¯çº¿ç¨‹æ²¡é”€æ¯
        if (destroyed) {
            throw new IllegalThreadStateException();
        }
        // threads æ•°ç»„ä»€ä¹ˆæ—¶å€™åˆå§‹åŒ–ä¸ºå¤§å°ä¸º 4 çš„ï¼Œ æ²¡æ‰¾åˆ°

       
        if (threads == null) {
            threads = new Thread[4];
        } else if (nthreads == threads.length) {
            threads = Arrays.copyOf(threads, nthreads * 2);
        }
        threads[nthreads] = t;

        // This is done last so it doesn't matter in case the
        // thread is killed
        // å› ä¸ºå¯åŠ¨çº¿ç¨‹æ•°åŠ  1 æ˜¯æœ€åå®Œæˆçš„ï¼Œå³ä½¿çº¿ç¨‹è¢«æ€æ­»ä¹Ÿæ²¡å…³ç³»
        nthreads++;

        // The thread is now a fully fledged member of the group, even
        // though it may, or may not, have been started yet. It will prevent
        // the group from being destroyed so the unstarted Threads count is
        // decremented.
        // å› ä¸ºçº¿ç¨‹å·²ç»æ·»åŠ åˆ°çº¿ç¨‹ç»„ä¸­ï¼Œå°½ç®¡çº¿ç¨‹çŠ¶æ€ä¸ç¡®å®šæ˜¯å¦å¯åŠ¨ï¼Œä½†æ˜¯è¯¥çº¿ç¨‹å·²ç»æ˜¯çº¿ç¨‹ä¸­çš„æ­£å¼æˆå‘˜ï¼Œæ‰€ä»¥æœªå¯åŠ¨çº¿ç¨‹å‡ä¸€
        nUnstartedThreads--;
    }
}
```


# å®ä¾‹å˜é‡å…±äº«é€ æˆçš„éçº¿ç¨‹å®‰å…¨é—®é¢˜
è‡ªå®šä¹‰çº¿ç¨‹ç±»ä¸­çš„å®ä¾‹å˜é‡é’ˆå¯¹å…¶ä»–çº¿ç¨‹å¯ä»¥åˆ†ä¸ºå¯å…±äº«å’Œä¸å…±äº«ä¸¤ç±»ã€‚è¿™åœ¨å¤šçº¿ç¨‹äº¤äº’æ—¶æ˜¯å¾ˆé‡è¦çš„æŠ€æœ¯ç‚¹ã€‚

## ä¸å…±äº«çš„æ•°æ®

è¯¥çº¿ç¨‹å†…æ‰€æ‹¥æœ‰èµ„æºå¯¹äºå…¶ä»–çº¿ç¨‹ä¸å¯è§ã€‚

### æµ‹è¯•ç”¨ä¾‹
åˆ›å»º ABC ä¸‰ä¸ªçº¿ç¨‹ï¼Œå„è‡ªä¸º ThreadVariable ç±»ä¸­çš„å˜é‡èµ‹å€¼ï¼Œç„¶åå¯åŠ¨ï¼Œä»£ç å¦‚ä¸‹ï¼š

```java
public class ThreadVariable implements Runnable{

    private int count;

    public void setCount(int count) {
        this.count = count;
    }

    @Override
    public void run() {
        while (count > 0){
            count--;
            System.out.println("ç”±" + Thread.currentThread().getName() + "è®¡ç®—ï¼Œ count=" + count);
        }
    }
}


public class ThreadTest {
    public static void main(String[] args) {
        // è®¾ç½® A çº¿ç¨‹ count
        ThreadVariable varT1 = new ThreadVariable();
        varT1.setCount(10);
        Thread t1 = new Thread(varT1);
        t1.setName("A");
        t1.start();

        ThreadVariable varT2 = new ThreadVariable();
        varT2.setCount(10);
        Thread t2 = new Thread(varT2);
        t2.setName("B");
        t2.start();

        ThreadVariable varT3 = new ThreadVariable();
        varT3.setCount(10);
        Thread t3 = new Thread(varT3);
        t3.setName("C");
        t3.start();
    }
}
```

ä¸€å…±åˆ›å»ºäº†ä¸‰ä¸ªçº¿ç¨‹ï¼Œæ¯ä¸ªçº¿ç¨‹éƒ½æ‹¥æœ‰è‡ªå·±çš„ count å˜é‡ï¼Œè‡ªå·±å‡å°‘è‡ªå·±çš„countå˜é‡ï¼Œå½¼æ­¤äº’ä¸å…±äº«ï¼Œã€‚

## å…±äº«çš„æ•°æ®

å…±äº«æ•°æ®çš„æƒ…å†µæ˜¯å¤šä¸ªçº¿ç¨‹å…±åŒè®¿é—®ä¸€ä¸ªå˜é‡ã€‚æ¯”è¾ƒå…¸å‹çš„åœºæ™¯æ˜¯å¤šä¸ªçº¿ç¨‹å…±åŒå¤„ç†ä¸€ä¸ªäººçš„ç¥¨æ•°ï¼Œå³å¤šç”¨æˆ·é€šè¿‡çº¿ä¸Šç»™æŸä¸€ä¸ªäººæŠ•ç¥¨ï¼Œè®¡æ•°ã€‚

ç”¨ä¸Šè¿°ä¾‹å­ï¼Œå°† count æ”¾åˆ° while å¾ªç¯ä¹‹å¤–ï¼Œç„¶ååˆ›å»ºå¤šä¸ªçº¿ç¨‹ï¼Œæ‰§è¡Œã€‚

æµ‹è¯•ä»£ç å¦‚ä¸‹ï¼š

```
System.out.println("=======================çº¿ç¨‹å˜é‡å…±äº« start=====================");
ThreadVariableShare varT4 = new ThreadVariableShare();
varT4.setCount(10);
Thread t4 = new Thread(varT1);
t4.setName("varT4");
t4.start();

ThreadVariableShare varT5 = new ThreadVariableShare();
Thread t5 = new Thread(varT2);
t5.setName("varT5");
t5.start();

ThreadVariableShare varT6 = new ThreadVariableShare();
Thread t6 = new Thread(varT3);
t6.setName("varT6");
t6.start();
System.out.println("=======================çº¿ç¨‹å˜é‡å…±äº« end=====================");
```
ä»”ç»†è§‚å¯Ÿæ‰“å°ç»“æœä¼šå‘ç°ï¼Œcount ä¼šæœ‰ç›¸åŒçš„å€¼è¢«ä¸åŒçš„çº¿ç¨‹æ‰“å°å‡ºæ¥ï¼Œè¿™æ ·å°±äº§ç”Ÿäº† "éçº¿ç¨‹å®‰å…¨" é—®é¢˜ï¼Œæ­£å¸¸æƒ…å†µä¸‹ï¼Œcount çš„è¾“å‡ºå€¼å› è¯¥æ˜¯é€’å‡çš„ï¼Œ
è€Œä¸åº”è¯¥æ˜¯é‡å¤çš„ã€‚

å‡ºç°é‡å¤å€¼æ˜¯å› ä¸ºåœ¨æŸäº› JVM ä¸­ï¼Œcount-- æ“ä½œè¦åˆ†è§£æˆå¦‚ä¸‹ 3 æ­¥(è€Œæ‰§è¡Œè¿™ 3 ä¸ªæ­¥éª¤çš„è¿‡ç¨‹ä¸­ä¼šè¢«å…¶ä»–çº¿ç¨‹æ‰“æ–­)ï¼š

1. å–å¾—åŸæœ‰ count å€¼ï¼›
2. è®¡ç®— count - 1ï¼›
3. å¯¹ count èµ‹å€¼ï¼›

è¿™ä¸‰æ­¥ä»»æ„ä¸€æ­¥éƒ½å¯èƒ½è¢«å…¶ä»–çº¿ç¨‹æ‰“æ–­ï¼Œä»è€Œé€ æˆå–å¾— count å€¼çš„ç»“æœä¸ä¸€è‡´ã€‚

ä¹¦ä¸­è¿˜ä»‹ç»äº†ä¸€ä¸ªæ¯”è¾ƒå…¸å‹çš„æ¡ˆä¾‹ï¼šServlet æŠ€æœ¯é€ æˆçš„éçº¿ç¨‹å®‰å…¨é—®é¢˜ä¸è§£å†³æ–¹æ¡ˆï¼š

éçº¿ç¨‹å®‰å…¨é—®é¢˜ä¸»è¦æ˜¯æŒ‡å¤šä¸ªçº¿ç¨‹å¯¹åŒä¸€ä¸ªå¯¹è±¡ä¸­çš„åŒä¸€ä¸ªå®ä¾‹å˜é‡è¿›è¡Œæ“ä½œæ—¶ä¼šå‡ºç°å€¼è¢«æ›´æ”¹ã€å€¼ä¸åŒæ­¥çš„æƒ…å†µï¼Œè¿›è€Œå½±å“ç¨‹åºçš„æ‰§è¡Œæµç¨‹ã€‚
ä»£ç å¦‚ä¸‹ï¼š

æ¨¡æ‹Ÿå®ç°ä¸€ä¸ªç»„ä»¶
```
/**
 * æ¨¡æ‹Ÿä¸€ä¸ª servlet ç™»é™†ç»„ä»¶
 */
public class ThreadServletLogin {
    private static String usernameRef;
    private static String passwordRef;

    public static void doPost(String username, String password){
        usernameRef = username;
        if(username.equals("a")){
            try {
                Thread.sleep(5000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        passwordRef = password;
        System.out.println("username= " + usernameRef + " password= " + passwordRef);
    }
}
```

åˆ›å»ºä¸¤ä¸ªçº¿ç¨‹æ¨¡æ‹Ÿç™»é™†
```
public class ThreadServletLoginA  extends Thread{
    @Override
    public void run() {
        ThreadServletLogin.doPost("a", "LoginA");
    }
}

public class ThreadServletLoginB extends Thread{
    @Override
    public void run() {
        ThreadServletLogin.doPost("b", "Loginb");
    }
}
```

æµ‹è¯•ç±»
```
public class ThreadServletLoginTest {
    public static void main(String[] args) {
        ThreadServletLoginA aLogin = new ThreadServletLoginA();
        aLogin.start();
        ThreadServletLoginB bLogin = new ThreadServletLoginB();
        bLogin.start();
    }
}
```

è¾“å‡ºç»“æœå°±ä¼šå‡ºç°ä»¥ä¸‹å‡ ç§æƒ…å†µï¼š
```
a bb
a aa
------
b aa
b bb
```



